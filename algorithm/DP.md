# DP (Dynamic Programming)



## DP란?

- Divide Conquer와 비슷하지만, 분할정복은 큰 문제를 해결하기 어려워 작은 문제로 나누어 푸는 방식이고, **DP는 작은 부분 문제들이 반복되는 것을 이용하여 푸는방법**

- 특정 조건을 만족하는 재귀함수로 표현되는 문제를 효과적으로 해결하는 기법

- 여러개의 하위 문제들을 푼 후, 그 결과를 쌓아 올려 주어진 문제를 해결하는 방식

- 문제 해결을 위한 **"점화식"** 을 찾아낸 후 점화식의 항을 밑에서부터 차례로 구해나가 답을 알아내는 형태
  - 코테 수준에서는 점화식만 이끌어 놓고 반복을 이용해서 돌면서 배열을 채워나가면 되는 문제가 나옴
  - 하지만, 뛰어난 수학적 직관력을 가지고 있지 않으면 점화식 이끌어 내기 어려움
  
- 입력으로 들어갈 파라미터 조합의 수가 적어야 함
  - 모든 파라미터에 대한 출력을 메모리상에 저장해야 함
  - 파라미터의 수가 너무 많으면 불가능
  
- 유한번 안에 종료됨이 보장되어야 함

- 자꾸 호출되고 시간이 오래 걸리면 중복으로 계산하지 말 것
  
  - 같은 호출에 대해 중복호출도 일어나고 실행 시간도 김
  
- 파라미터에 대해 반환값이 고정적이라면 다시 계산할 필요 없음

- 재귀함수로 구현한 대부분의 것은 Top-down 형식이라고 생각할 수 있음
  - 재귀로 구현하면 시간복잡도가 너무 높아질 수 있음 (지수적으로 수가 증가)
  - 이러한 이유 때문에 이전에 계산한 값을 저장해두고 가져와서 사용하는 방식 이용
  
- Bottom-Up은 작은 값부터 해결해 나가는 방식이라고 볼 수 있음

  - Tabulation (타뷸레이션)

- Top-Down

  - Memoizaion (메모이제이션)

- **최적 부분구조**와 **중복되는 부분 문제**에서 사용할 수 있음
  
  - 최적 부분구조를 갖는다는 것은, 다른 결과로 현재의 결과를 얻을 수 있는 것을 뜻함
    - 작은것으로 계속 쪼개져 나가보다 보면 현재 값을 알 수 있음
  
- 어떤 문제의 입력사례의 최적해가 그 입력사례를 분할한 부분사례에 대한 최적해를 항상 포함하고 있으면, 그 문제에 대하여 최적의 원리가 성립한다.

  - 집합 A를 n개의 보석들 중에 최적으로 고른 부분집합이라고 가정하자

    - 집합 A가 n번째 보석을 포함하고 있지 않다면, A는 n번째 보석을 뺀 나머지 n-1 개의 보석들 중에서 최적으로 고른 부분집합과 같다.
    - 집합 A가 n번째 보석을 포함하고 있다면, A에 속한 보석들의 총 가격은 n-1개의 보석들 중에서 최적으로 고른 가격의 합에다가 보석 n의 가격을 더한것과 같다.

    ![점화식](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fmu4jC%2Fbtqvpjvm4kE%2FGrSkkh7biC6auBoVx0tscK%2Fimg.png)

    - P[i, w]란 i개의 보석이 있고 배낭의 무게 한도가 w일때 최적의 이익
      - i번째 보석이 배낭의 무게 한도보다 무거우면 넣을 수 없으므로 i번째 보석을 뺀 i-1개의 보석들을 가지고 구한 전 단계의 최적 값을 그대로 가져옴
      - i번째 보석을 위해 i번째 보석만큼의 무게를 비웠을때의 최적값에 i번째 보석의 가격을 더한 값 또는 i - 1개의 보석들을 가지고 구한 전 단계의 최적값 중 큰 것을 선택

  > https://gsmesie692.tistory.com/113


## Memoization 

- 하향식 (Top-down)
- 하위 문제에 대한 정답을 계산했는지 확인해가며 문제를 풀어나가는 방식
- 이미 **계산 된 적 있는** 함수의 반환 값을 메모리상에 기억해 두는 것
  - 다음 번에 계산 없이 값 호출
- 파라미터마다 다른 출력을 가질 수 있음
  - 반환 값은 파라미터 조합마다 구분되어야 함
  - Key-Value pair 형식의 구조에 저장하면 됨
  - 일반적으로 배열을 사용하지만 Map도 사용 가능
- 함수의 각 파라미터에 대한 반환 값을 저장하는 공간을 **상태공간**이라고 부름
- 재귀 이용해서 값 저장하고 저장된 값을 사용

```python
def fib(n):
	if n <= 1:
			return n
  
  # 값이 계산된게 있으면 그 값 리턴
  if dp[n]:
  		return dp[n]
  		
  dp[n] = finb(n-1) + fib(n-2)
  return dp[n]
```

- 피보나치 같은 것은 재귀로 풀게되면 한계가 존재하기 때문에 동적 계획법 사용하면 좋음



## Tabulation

- 상향식 (Bottom-Up)
- 더 작은 하위 문제부터 살펴본 다음, 작은 문제의 정답을 이용해 큰 문제의 정답을 풀어나감
- 일반적으로 사용하는 방식
- 데이터를 테이블 형태로 만들면서 풀이하는 형태

```python
def fib(n):
  dp[0] = 0
  dp[1] = 1
  
  for i in range(2, n + 1):
    dp[i] = dp[i - 1] + dp[i - 2]
  return dp[n]
```





## DP 설계

- Optimal Substructure 구조
  - 전체를 여러 작은 문제로 나누어 계산 후 정답 계산
  - 더 작은 범위의 함수들을 호출 후 정답 계산
- 파라미터의 정의역이 작아야 함
- 구현방식은 Top-Down, Down-Top 2가지 방식 존재
  1. Top-Down (하향식 접근법)
     - **재귀 함수**로 파라미터에 대한 해의 계산 과정 구현
     - 하위 문제데 대한 정답을 계산했는지 확인해가며 문제 푸는 방식 (메모이제이션 , Memoization)

## 출처

> 구름EDU-알고리즘 문제해결기법 입문
>
> https://galid1.tistory.com/507



## 배낭 문제 Knapsack Problem

### 쪼갤 수 있는 배낭문제 Fraction Knapsack Problem

- Greedy 이용

### 쪼갤 수 없는 배낭 문제 0/1 Knapsack Problem

- DP 이용
- 타뷸레이션 하는 DP