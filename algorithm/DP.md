# DP (Dynamic Programming)



## DP란?

- Divide Conquer와 비슷하지만, 분할정복은 큰 문제를 해결하기 어려워 작은 문제로 나누어 푸는 방식이고, DP는 작은 부분 문제들이 반복되는 것을 이용하여 푸는방법
- 특정 조건을 만족하는 재귀함수로 표현되는 문제를 효과적으로 해결하는 기법
- 여러개의 하위 문제들을 푼 후, 그 결과를 쌓아 올려 주어진 문제를 해결하는 방식
- 문제 해결을 위한 **"점화식"** 을 찾아낸 후 점화식의 항을 밑에서부터 차례로 구해나가 답을 알아내는 형태
  - 코테 수준에서는 점화식만 이끌어 놓고 반복을 이용해서 돌면서 배열을 채워나가면 되는 문제가 나옴
  - 하지만, 뛰어난 수학적 직관력을 가지고 있지 않으면 점화식 이끌어 내기 어려움
- 입력으로 들어갈 파라미터 조합의 수가 적어야 함
  - 모든 파라미터에 대한 출력을 메모리상에 저장해야 함 (Memoization)
  - 파라미터의 수가 너무 많으면 불가능
- 유한 번 안에 종료됨이 보장되어야 함
- 자꾸 호출되고 시간이 오래 걸리면 중복으로 계산하지 말 것
  - 같은 호출에 대해 중복호출도 일어나고 실행 시간도 김
- 파라미터에 대해 반환값이 고정적이라면 다시 계산할 필요 없음
- 재귀함수로 구현한 대부분의 것은 Top-down 형식이라고 생각할 수 있음
  - 재귀로 구현하면 시간복잡도가 너무 높아질 수 있음 (지수적으로 수가 증가)
  - 이러한 이유 때문에 MeMoization 사용
- Bottom-Up은 DP처럼 작은 값부터 해결해 나가는 방식이라고 볼 수 있음
- **최적 부분구조**와 **중복되는 부분 문제**에서 사용할 수 있음
  - 최적 부분구조를 갖는다는 것은, 다른 결과로 현재의 결과를 얻을 수 있는 것을 뜻함
    - 작은것으로 계속 쪼개져 나가보다 보면 현재 값을 알 수 있음


## Memoization

- 이미 계산 된 적 있는 함수의 반환 값을 메모리상에 기억해 두는 것
  - 다음 번에 계산 없이 값 호출
- 파라미터마다 다른 출력을 가질 수 있음
  - 반환 값은 파라미터 조합마다 구분되어야 함
  - Key-Value pair 형식의 구조에 저장하면 됨
  - 일반적으로 배열을 사용하지만 Map도 사용 가능
- 함수의 각 파라미터에 대한 반환 값을 저장하는 공간을 **상태공간**이라고 부름

```pseudocode
function (param x){
	if(memo[x] is exists){
		return memo[x]
	}else{
		answer <- compute(x)
		memo[x] <- answer
		return memo[x]
	}
}
```

- 피보나치 같은 것은 재귀로 풀게되면 한계가 존재하기 때문에 동적 계획법 사용하면 좋음



## DP 설계

- Optimal Substructure 구조
  - 전체를 여러 작은 문제로 나누어 계산 후 정답 계산
  - 더 작은 범위의 함수들을 호출 후 정답 계산
- 파라미터의 정의역이 작아야 함
- 구현방식은 Top-Down, Down-Top 2가지 방식 존재
  1. Top-Down
     - 재귀 함수로 파라미터에 대한 해의 계산 과정 구현
     - 



## 출처

> 구름EDU-알고리즘 문제해결기법 입문
>
> https://galid1.tistory.com/507