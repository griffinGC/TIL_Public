# 세그먼트 트리

- 여러 개의 데이터가 연속적으로 존재할때 특정한 범위의 데이터의 합을 구하는 방법
- 구간의 합중에 최소값을 구하는데 사용할 수 있음
- 시간 복잡도는 O(NlogN)
- 연산 비교
  - 구간이 주어졌을때, A[l] + A[l+1] + ... + A[r-1] + A[r]
    - 세그먼트 트리를 이용하면 O(logN)
    - 일반적으로는 O(N)
  - i 번째 수를 v로 바꾸기. A[i] = v
    - 세그먼트 트리를 이용하면 O(logN)
    - 일반적으로는 O(1)



## 세그먼트 트리

- 리프 노드 
  - 배열의 그 수 자체
- 다른 노드
  - 왼쪽 자식과 오른쪽 자식의 합 저장

- 노드 번호가 X일때 왼쪽 자식 노드 번호는 2X, 오른쪽 자식 노드 번호는 2X + 1



## N이 10인 경우 세그먼트 트리 (N은 배열의 총 갯수 == 리프노드의 갯수)



![node](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/blog/seg1.png)

각 노드가 저장하고 있는 합의 범위



![노드번호](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/blog/seg2.png)

노드 번호



## 노드 만들기

- N이 2의 제곱꼴인 경우
  - Full Binary Tree
  - 높이는 logN
  - 리프 노드가 N개인 Full Binary Tree는 필요한 노드의 개수가 2*N - 1개
- N이 2의 제곱꼴이 아닌 경우
  - 높이는 logN
  - 총 세그먼트 트리를 만드는데 필요한 배열의 크기는 2^(H+1) - 1

```java
// arr : 배열
// tree : 세그먼트 트리
// node : 세그먼트 트리 번호
// node가 담당하는 합의 범위 start ~ end
private static long init(long[] arr, long[] tree, int node, int start, int end){
    // 리프 노드인 경우
    if(start == end){
        return tree[node] = arr[start];

    // 리프 노드가 아닌 경우 => 자식 원소2개를 합쳐서 나타냄
    } else {
        return tree[node] = init(arr, tree, node * 2, start, (start + end) / 2) + init(arr, tree, node * 2 + 1, (start + end) / 2 + 1, end);
    }
}
```

- 재귀를 이용해 왼쪽 자식 트리와 오른쪽 자식 트리를 만들고 그 합을 저장



## 노드 값 합치기

- 노드의 값을 합쳐서 원하는 구간의 값을 알아내기

  - 0 ~ 9 : 루트 노드
  - 2 ~ 4 : 3~4 + 2

- 노드가 담당하고 있는 구간 [start, end], 합을 구해야하는 구간 [left, right]

  1. [left, right]와 [start, end]가 겹치지 않는 경우
     - right < start || left > end

  2. [left, right]가 [start, end]를 완전히 포함하는 경우
     - left <= start && right >= end
     - 범위에 모두 포함되기 때문에 node의 자식도 모두 포함되어서 tree[node] 리턴
  3. [start, end]가 [left, right]를 완전히 포함하는 경우

  4. [left, right]와  [start, end]가 겹쳐져 있는 경우
     - 3,4 번의 경우 재귀를 이용하여 왼쪽 자식과 오른쪽 자식을 루트로 하는 트리에서 다시 탐색

## 노드 값 변경

- 중간에 어떤 수를 변경한다면, 그 숫자가 포함된 구간을 담당하는 모든 노드를 변경해야 함

- 3을 변경할 때

  ![3변경](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/blog/seg7.png)

- 변경되는 경우

  1. [start, end]에 index가 포함되는 경우

  2. [start, end]에 index가 포함되지 않는 경우

     



## 참고자료

> https://blog.naver.com/ndb796/221282210534
>
> https://www.acmicpc.net/blog/view/9