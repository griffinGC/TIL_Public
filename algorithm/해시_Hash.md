# Hash (해시)

- 임의 크기 데이터를 고정 크기 값으로 매핑하는데 사용할 수 있는 함수
- 해싱 (Hashing)
  - 해시 테이블을 인덱싱하기 위해 해시 함수를 사용하는 것
  - **키를 해시 함수에 넣으면 해싱값을 리턴하고 그 해싱값에 데이터를 저장**
- 장점
  - **적은 자원으로 많은 데이터를 효율적으로 관리 가능**
    - 무한한 데이터를 유한한 갯수의 해시값으로 매핑하면 작은 메모리로도 프로세스 관리 가능
  - **빠른 검색, 삽입, 삭제 속도**
    - 평균 O(1)
    - 최악 O(n) => 충돌 때문에 늦어짐
  - 키와 해싱 값이 관련없기 때문에 보안에도 많이 사용 됨
  - 중복 제거시 유용
  - 데이터 캐싱에 사용
- 단점
  - 충돌 발생 가능
  - 공간 복잡도가 커짐
- **손실 압축, 무작위화 함수, 암호** 등과 관련 깊음
- 충돌 해결책
  1. **개별 체이닝**
  2. **오픈 어드레싱**
- 성능 좋은 해시 함수 특징
  - 해시 함수 값 충돌의 최소화
  - 쉽고 빠른 연산
  - 해시 테이블 전체에 해시 값이 균일하게 분포
  - 사용할 키의 모든 정보를 이용하여 해싱
  - 해시 테이블 사용 효율이 높을 것
- 파이썬의 딕셔너리가 해시로 이루어진 것 **(오픈어드레싱)**
  - 대신 로드팩터를 작게 잡아서 성능저하문제 해결



## Load Factor 로드 팩터

- 해시 테이블에 저장된 데이터 개수 n을 버킷의 갯수 k로 나눈 것
- load factor = n / k
  - 자바 10에서는 0.75, 넘을 경우 해시 테이블 공간 재할당



## Hashing (해싱)

- 해싱 방식
  - 나눗셈 방식 (Modulo - Division Method)
    - h(x) = x mod m
    - m : 해시 테이블 크기
    - x : 입력 값

- 해싱 함수를 이용하여 **키** 값에 대한 **고유한 숫자**를 만들어 냄
  - 이것을 배열의 **인덱스**로 사용하기 때문에, 키 값과 해싱값 간에 연관성이 없어 보안에도 잘 사용 됨
  - 언제나 동일한 값 리턴

## Collision (충돌)

- 충돌 해결 방식
  - Separate Chaining (개별 체이닝)
  - Open addressing (오픈 어드레싱)



### Separate Chaining (개별 체이닝)

- 충돌 발생시 충돌 발생한 곳을 연결 리스트로 연결하는 방식
  - 무한정 저장 가능
  - 메모리 문제 발생 가능
- 방식
  1. 키의 해시 값 계산
  2. 해시 값을 이용해 배열의 인덱스 구함
  3. 같은 인덱스가 있다면 연결리스트로 연결
- 구현 방식
  - LinkedList
  - Red-Black Tree (RBT)
- 대부분 탐색 O(1)
- 최악의 경우 O(n)
- Java7에서 HashMap 사용할때 이용하는 방식



### Open addressing (오픈 어드레싱)

- 충돌 발생 시 탐사(Probing)를 통해 **빈 공간**을 찾아나서는 방식
- **자신의 해시 값과 일치하는 주소에 저장된다는 보장 없음**
- 같은 곳에 계속 저장하기 때문에 Separate Chaining보다 캐시 효율이 높음
- 전체 슬롯의 개수 이상은 저장할 수 없음
  - 기준이 되는 로드 팩터 비율을 넘어서게 되면, Growth Factor (그로스 팩터)의 비율에 따라 더 큰 크기의 또 다른 버킷을 생성한 후 여기에 새롭게 복사하는 리해싱 작업 진행
- 탐사 방식
  - 선형 탐사 (Linear Probing)
    - 충돌이 발생할 경우, 해당 위치부터 순차적으로 탐사를 하나씩 진행
    - 특정 위치가 선점되어 있으면 바로 그 다음 위치를 확인하는 형태
    - 데이터들이 고르게 분포되지 않고 뭉치는 경향 발생
      - 클러스터링

