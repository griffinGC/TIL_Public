# Item 24, 25, 26

## Item 24 멤버 클래스는 되도록 static으로 만들라

- 중첩 클래스 종류
  - 정적 멤버 클래스
  - (비정적) 멤버 클래스
  - 익명 클래스
  - 지역 클래스
- 정적 멤버 클래스를 제외한 나머지는 내부 클래스

### 정적 멤버 클래스

- 바깥 클래스와 함께 쓰일 때만 유용한 public 도우미 클래스
  - ex. Calculator.Operation.PLUS, Calculator.Operation.MINUS

### 정적 멤버 클래스와 비정적 멤버 클래스의 차이

- 비정적 멤버 클래스의 인스턴스는 바깥 클래스의 인스턴스와 암묵적으로 연결됨
- 비정적 멤버 클래스의 인스턴스 메서드에서 정규화된 this(***클래스명***.this)를 사용해 바깥 인스턴스의 메서드를 호출하거나 바깥 인스턴스의 참조를 가져올 수 있음
- 중첩 클래스의 인스턴스가 바깥 인스턴스와 독립적으로 존재할 수 있다면 정적 멤버 클래스로 만들어야 함
- 비정적 멤버 클래스는 바깥 인스턴스 없이는 생성 불가
- 비정적 멤버 클래스의 인스턴스와 바깥 인스턴스 사이의 관계는 멤버 클래스가 인스턴스화될 때 확립되며, 더 이상 변경 불가
  - 위의 관계는 바깥 클래스의 인스턴스 메서드에서 비정적 멤버 클래스의 생성자를 호출할때 자동으로 생성됨
    - 드물게는 직접 바깥 인스턴스의 클래스.new Member Class(args)를 호출해 수동으로 만듬
- 비정적 멤버 클래스는 어댑터를 정의할때 자주 쓰임
- **멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static을 붙여서 정적 멤버 클래스로 만들자**
  - static을 생략하면 바깥 인스턴스로의 숨은 외부 참조를 갖게 되므로써, 시간과 공간이 소비 됨
  - 가비지 컬렉션이 바깥 클래스의 인스턴스를 수거하지 못하는 메모리 누수가 생길 수 있음
- private 정적 멤버 클래스
  - 바깥 클래스가 표현하는 객체의 한 부분(구성요소)을 나타낼때 사용
- 공개된 클래스의 public 혹은 protected 멤버 클래스
  - 정적이냐 아니냐가 매우 중요
  - 멤버 클래스 역시 공개 API가 됨
  - 향후 릴리스에서 static을 붙이면 하위 호환성이 깨짐

### 익명 클래스

- 바깥 클래스의 멤버 아님
- 쓰이는 시점에 선언과 동시에 인스턴스 생성
- 비정적인 문맥에서 사용될 때만 바깥 클래스의 인스턴스를 참조할 수 있음
- 정적 문맥에서는 상수 변수 이외의 정적 멤버는 가질 수 없음
- 응용에 제약이 많음
- 선언된 지점에서만 인스턴스 생성 가능
- instanceof 검사나 클래스의 이름이 필요한 작업은 수행할 수 없음
- 여러 인터페이스 구현 불가
- 인터페이스를 구현하는 동시에 다른 클래스 상속 불가
- 익명 클래스를 사용하는 클라이언트는 그 익명 클래스가 상위 타입에서 상속한 멤버 외에는 호출 불가
- 짧지 않으면 가독성이 떨어짐
- 람다 지원 전에는 즉석에서 작은 함수 객체나 처리 객체를 만드는데 주로 사용
- 정적 팩터리 메서드 구현할때 사용 가능

### 지역 클래스

- 지역변수를 선언할 수 있는 곳이면 어디서든 선언 가능
- 유효범위는 지역변수와 동일
- 멤버 클래스처럼 이름이 있고 반복해서 사용 가능
- 익명 클래스 처럼 비정적 문백에서 사용될 때만 바깥 인스턴스를 참조 가능
- 정적멤버는 가질 수 없음
- 가독성을 위해 짧게 작성해야 함

### 정리

- 멤버 클래스 
  1. 메서드 밖에서도 사용해야 하는 경우
  2. 메서드 안에 정의하기에 너무 길 경우
- 비정적
  - 멤버 클래스의 인스턴스 각각이 바깥 인스턴스를 참조할 경우
- 정적
  - 비정적 이외의 경우
- 익명 클래스
  - 중첩 클래스가 한 메서드 안에서만 쓰이며, 그 인스턴스를 생성하는 지점이 단 한곳이고, 해당 타입으로 쓰기에 적합한 클래스나 인터페이스가 이미 있는 경우



## Item 25 톱레벨 클래스는 한 파일에 하나만 담으라

- 한 파일에 톱레벨 클래스 여러개 선언하는 경우 문제점

  - 한 클래스를 여러 가지로 정의 가능

  - 어느 것을 사용할지는 어느 소스 파일을 먼저 컴파일 하느냐에 따라 달라짐

ex. 소스파일은 Main 클래스 하나 담고 있고, Main 클래스는 다른 톱레벨 클래스 2개 (Utensil, Dessert) 참조

```java
// Main Class
public class Main {
  public static void main(String[] args){
    System.out.println(Utensil.NAME + Dessert.NAME);
  }
}
```



```java
// Utensil.java
class Utensil {
  static final String NAME = "pan";
}

class Desert {
  static final String NAME = "cake";
}
```

```java
// Desert.java
class Utensil {
  static final String NAME = "pot";
}

class Desert {
  static final String NAME = "pie";
}
```

#case 1 (javac Main.java Desert.java 실행)

- 컴파일 오류 발생 (클래스 중복 정의)
- 컴파일러 실행 순서

  1. Main.java 컴파일
  2. Utensil 참조 만날 경우, Utensil.java 파일에서 Utensil과 Dessert 모두 찾아냄
  3. Dessert.java를 실행할때 같은 클래스의 정의가 이미 있음을 알게 됨



#case 2 (javac Main.java Utensil.java 실행)

- pancake 출력
- 컴파일러 실행 순서

  1. Main.java 컴파일
  2. Utensil 참조 만날 경우, Utensil.java 파일에서 Utensil과 Dessert 모두 찾아냄
  3. pancake 출력



#case 3 (javac  Desert.java Main.java 실행)

- potpie 출력
- 컴파일러 실행 순서

  1. Dessert.java 컴파일
  2. Main.java 컴파일 Utensil 참조 만날 경우, Dessert.java 파일에서 Utensil과 Dessert 모두 찾아냄
  3. potpie 출력



**컴파일러에 어느 소스 파일을 먼저 건네느냐에 따라 동작이 달라진다.**



### 정리

- **소스 파일 하나에는 반드시 톱레벨 클래스(혹은 톱레벨 인터페이스)를 하나만 담아라**



## Item 26 로(Raw) 타입은 사용하지 말라

- **제네릭 클래스** 혹은 **제네릭 인터페이스**

  - 클래스와 인터페이스 선언에 타입 매개변수(type parameter)가 쓰인 경우
  - 통칭하여 **제네릭 타입** 이라고도 부름

- 각각의 제네릭 타입은 일련의 **매개변수화 타입**(parameterized type)을 정의 함

  - ex. `List<String> ` : 원소의 타입이 String인 리스트를 뜻하는 매개변수화 타입

- 로 타입 (Raw type)

  - 제네릭 타입을 하나 정의 하면 그에 딸린 로 타입(Raw type)도 함께 정의 됨
  - 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 뜻함
  - ex. `List<E>`의 Raw 타입은 `List`

- Example

  ```java
  // Stamp 인스턴스만 취급
  private final Collection Stamps = ...;
  // 실수로 동전 삽입
  stamps.add(new Coin(...));
  ```

  - Stamp 대신 Coin을 넣어도 아무 오류 없이 컴파일 되고 실행됨

- 로 (Raw) 타입을 쓰는걸 언어 차원에서 막지는 않았지만 절대 쓰지 말아야 한다.

- **로 (Raw) 타입을 쓰면 제네릭이 안겨주는 안정성과 표현력을 모두 잃게 된다.**

- 로 (Raw) 타입은 호환성 때문에 존재함

  - 제네릭 이전의 기존 코드를 모두 수용하면서 제네릭을 사용하는 새로운 코드와도 맞물리게 돌아가게 하기 위함

- **`List<Object>` 같은 매개변수화 타입을 사용할 때와 달리 `List` 같은 로 타입을 사용하면 타입 안정성을 잃게 된다.**

  - `List<String>`은 로 타입인 List의 하위 타입이 이지만,`List<Object>`은 로 타입인 List의 하위 타입이 아니다.

- 원소의 타입을 몰라도 되는 로 타입을 쓰고 싶을 경우

  - 비한정적 와일드카드 타입 (unbounded wildcard type)을 대신 사용하는게 좋음
    - 어떤 타입이라도 담을 수 있는 가장 범용적인 매개변수화 Set 타입

  ```java
  static int numElementsInCommon(Set<?> s1, Set<?> s2){ ... }
  ```

  - 와일드 카드 타입은 안전하고 로 타입은 안전하지 않음
    - 로 타입 컬렉션에는 아무 원소나 넣을 수 있으니 타입 불변식을 훼손하기 쉬움
    - **Collection<?>에는 (null 외에는) 어떤 원소도 넣을 수 없음**

- 예외

  - **class 리터럴에는 로 타입을 써야 함**
    - ex.` List.class`는 가능 `List<String>.class`는 불가능

  - 런타임에는 제네릭 타입 정보가 지워지므로 instanceof 연산자는 비한정적 와일드 카드 타입 이외의 매개변수화 타입에는 적용할 수 없음

    - 로 타입이든 비한정적 와일드 카드 타입이든 instanceof는 완전히 똑같이 동작

    ```java
    if(o instanceof Set){
      Set<?> s = (Set<?>) o;
    }
    ```

    - o의 타입이 Set임을 확인한 다음 와일드 카드 타입인 Set<?>로 형변환 해야 함

---

- 공개된 클래스의 public 혹은 protected인 멤버 클래스라면 향후 릴리스에서 static을 붙이면 왜 하위 호환성이 깨짐?
- 표현력이란?
- Collection<?>에는 null 외에는 어떤 원소도 넣을 수 없다? 무슨말인지 모르겠음

