# 객체지향 프로그래밍 (Object Oriented Programming)

> https://jeong-pro.tistory.com/95

- **현실 세계의 사물들을 객체로 보고, 객체로부터 원하는 어플리케이션의 특징**을 뽑아 프로그래밍하는 프로그래밍 패러다임
  - 객체를 이용해서 특정한 개념의 함수와 자료형을 함께 묶어서 관리
  - 객체 내부에 함수(메소드)와 필드(자료형)이 존재
  - **상태**와 **행위**로 구분해서 카테고라이징 해놓은 것이 객체
- 객체들을 레고 블럭처럼 조립해서 하나의 프로그램으로 만드는 것
  - 즉, 객체를 만드는 것
- 강한 응집력 + 약한 결합력
  - Strong Cohesion + Weak Coupling



## 장점

- 객체를 이용함으로써 프로그램을 유연하고 변경이 용이하게 가능해줌
  - **코드 재사용 용이**
- 소프트웨어의 개발과 유지보수가 편함
  - **유지보수 쉬움**
- 직관적인 코드 분석을 가능하게 해줌
- 대형 프로젝트에 적합
  - 모듈화 가능하기 때문 => 업무분담이 쉬움



## 단점

- 지나친 객체화 경향은 실제 세계의 모습을 그대로 반영 불가
  - 좋은 설계가 필요
    - 설계시 많은 시간과 노력이 필요함
- 처리 속도가 상대적으로 느림
  - 캡슐화와 격리 구조때문에 절차지향보다 속도가 느림
- 객체가 많으면 용량이 커질 수 있음



## 메인 키워드

- **클래스 + 인스턴스 (객체)**
  - **속성(변수) + 행위(메소드)**
- **추상화 (Abstraction)**
  - **공통적으로 필요로 하는 속성이나 기능을 추출하는 것** (뼈대만 남기는 것)
  - 유연성을 가지게 해줌
    - 추후에 추가로 구현할 부분이 생기면 다른 코드는 수정할 필요 없이 추가해 주면 됨
- **캡슐화 (Encapsulation)**
  - 객체의 속성과 행위를 하나로 묶음
    - 낮은 결합도를 유지하게 해줌
    - 재활용 가능
  - 정보 은닉으로 객체가 내부적으로 어떻게 동작하는지 감추고 접근 불가하도록 함
    - 보안성 향상
    - 내부의 값을 함부로 변경할 수 없음
    - 다른 외부 모듈과의 낮은 결합도를 유지할 수 있음
- **상속 (Inheritance)**
  - 부모의 속성과 기능을 그대로 이어받아 사용할 수 있음
  - 또한, 필요한 부분은 상속받은 자식클래스에서 해당 기능만 다시 재정의 가능
  - 재사용이 아닌 기능의 확장 관점일때 사용 추천
  - **코드의 중복을 없앨 수 있음**
  - **유지 보수 용이**
  - 단점
    - 상위 클래스의 변경이 어려움
    - 불필요한 클래스 증가
    - 상속이 잘못 될 수 있음
- **다형성 (Polymorphism)**
  - **하나의 변수명, 함수명등이 상황에 따라 다른 의미로 해석될 수 있는 것**
    - 상속받아서 오버라이딩하면 다른 의미가 되고
    - 오버로딩 하면 이름은 같지만 다른 의미가 됨 (매개변수 갯수, 데이터 타입) 
      - 리턴타입은 상관없음
      - 오버로딩을 이용하면 매개값을 다양하게 받아 처리 가능
  - 상속과 함께 사용시 도움이 많이 됨
  - 코드를 **간결**하게 해주고, **유연함**을 갖추게 해줌
  - 자바에서는 부모 클래스나 인터페이스 타입에 구현 객체나 자식 객체를 대입할 수 있음
    - 그러면 부모 클래스의 메소드와 필드만을 사용, 예외적으로 자식에서 오버라이딩 된게 있다면 그것을 사용함
    - 그리고 자식에만 정의된 메소드와 필드는 사용 불가



## 설계

- 좋은 설계는 현실을 잘 반영하는 것
  - 하지만, 복잡함 전체가 필요한 것은 아님
- 복잡함 속에서 필요한 관점만을 추출하는 행위인 **"추상화"** 가 필요함
  - 좋은 설계를 위해서는 고도의 추상화 능력이 필요함

- 좋은 설계는 지식이라기보다 지혜의 영역
  - 스스로 경험하고 깨우쳐서 자기화 시켜야 함
- 일단은 문법을 익히고 설계 원칙에 대해서 생각해 볼 것



## 부품화

- 객체는 일종의 **부품**으로써 사용됨

- 부품화를 시키는 기준이 바로 추상화
- 메소드는 부품화의 예
  - 메소드를 사용하면 코드의 양을 줄일 수 있음
  - 필요한 코드를 찾기 쉽고, 문제의 진단도 빨라짐
- 연관된 메소드와 그 메소드가 사용하는 변수들을 분류하고 그룹핑 해야 함
  - 그런 그룹핑 대상이 객체
  - 예를 들면, 파일과 디렉토리가 존재한다면
    - 메소드나 변수는 파일
    - 객체는 디렉토리



## 은닉화, 캡슐화

- 내부의 동작 방법을 숨기고, 사용자에게는 그 부품의 사용방법만을 노출하는 것
- 사용자에게는 사용하는 방법만 중요하게 만드는 것



## 인터페이스

- **부품들간의 약속**
  - 예를 들면, A사의 모니터를 쓰다가 B사의 모니터를 쓸 수 있는 이유는 HDMI라는 표준 케이블 규격 덕분임
    - 이러한 연결점이 바로 인터페이스
- 서로 어떤식으로 만들어 졌는지는 신경쓰지 않음.
  - 정해진 약속에 따라 연결할 수 있기만 하면 됨
  - 구현체를 신경쓸 필요가 없음
- 이질적인 것들이 결합하는 것을 막아주는 역할도 함
- 장점
  - 



#### **비유한 것이지만 비유의 함정에 빠지지않게 조심해야 함!!**



## 출처

> https://opentutorials.org/module/516/5399
>
> https://opentutorials.org/module/516/6063