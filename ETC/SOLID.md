# SOLID Principles

> https://levelup.gitconnected.com/solid-principles-simplified-with-illustrations-fe5265f68ec6

- 위의 아티클을 번역하고 요약한 글

> https://www.nextree.co.kr/p6960/

## 요약

- 잘못 설계된 legacy 코드를 수정하는 것은 어렵다.

- 처음에 설계할때 잘 설계하는 것이 중요하다. 이를 위해 5가지 원칙이 존재한다.

- 5가지 원칙

  - Single Responsibility Principle (SRP)

    - 한번에 한가지 책임
  - 클래스를 변경하는 이유는 단 한개여야 함
    - 이를 어기면 한 책임의 변경에 의해 다른 책임과 관련된 코드에 영향이 갈 수 있음
  - **코드의 가독성 향상**
    - **유지보수 용이**
  
  - Open Closed Principle (OCP)
  
    - **확장에 열려있고 수정에 닫혀있어야 함**
    - 모듈 확장 가능
    - 새로운 기능이 추가될 경우 클래스는 **확장** 되어야 함
  - **기능을 사용하는 코드는 수정하지 않음**
      - 모듈의 코드를 수정하지 않아도 모듈의 **기능을 확장하거나 변경** 가능
  - **관리 가능하고 재사용 가능한 코드를 만들어줌**
    - 시스템의 행동을 확장시키도록 만들기 위해서는 **분리** 되어야 함
  - Switch 문을 하나의 인터페이스 혹은 추상 클래스와 그것을 구현 혹은 상속받는 여러개의 클래스를 이용하여 구현
      - 이를 이용하여 새로운 조건에 대해 클래스를 생성하고 기존의 클래스는 수정안해도 됨
  - **잘 적용된다면 이미 잘 동작되는 원래 코드는 변경하지 않고, 기존의 코드에 새로운 코드를 추가함으로써 기능의 추가나 변경 가능**
  
  - Liskov Substitution Principle

    > https://vandbt.tistory.com/41

    - 같은 클래스를 상속받는 객체는 기존의 코드에 영향을 주지 않고 서로를 대체할 수 있어야 함
    - 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 함
    - **다형성을 통한 확장성이 좋아짐**
  
  - Interface Segregation Principle
  
    - **사용하지 않는 메소드는 인터페이스 내에 정의하지 않도록 함**
    - 인터페이스가 너무 클 경우 여러개의 작은 인터페이스로 나누는 방식 추천
    - 인터페이스는 인터페이스를 사용하는 클라이언트를 기준으로 분리
  
  - Dependency Inversion Principle
  
    - low-level module과 high-level module이 밀접하게 결합되지 않도록 해야 함
    
      - 둘 다 추상화에 의존해야함
    
    - low-level module이 변경 되어도 high-level module이 영향을 받지 않도록 low-level에 대한 인터페이스를 정의해주는것도 하나의 방식이 될 수 있음
    
      - 하위 레벨이 변경되어도 상위 레벨에 영향이 안가도록 해야 함
      - 상위 레벨이 저수준 모듈의 구현에 의존해서는 안됨
    
    - 느슨하게 결합 되어 있으면 독립적으로 테스트 가능
    
      

