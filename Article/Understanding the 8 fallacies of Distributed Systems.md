# [번역] 분산 시스템의 8가지 잘못된 통념의 이해

분산 시스템에서 일하는가? 만약 마이크로서비스 웹 APIs, SOA, 웹서버, 어플리케이션 서버, 데이터베이스 서버, 캐시 서버, 로드 밸런서 같은 컴포넌트들을 시스템 설계에서 사용한다면, 대답은 '예' 이다. 분산 시스템은 공통의 목표를 달성하기 위해 합쳐진 많은 컴퓨터들로 구성된다.



20년도 더 전에 Peter Deutsch 와 James Gosling은 분산 컴퓨팅의 8가지 오류를 정의 했다. 이러한 것들은 분산 시스템에 관해 많은 개발자들이 잘못 가정하게 만드는 것들이다. 이러한 것들은 버그들을 수정하는 것을 어렵게 만들면서, 긴 시간을 통해 일반적으로 잘못된 것으로 증명되었다.



8가지 오류는 아래와 같다.

1. 네트워크는 신뢰할 수 있다.
2. 지연은 없다.
3. 대역폭 (데이터 전송 능력)은 무한하다.
4. 네트워크는 안전하다.
5. Topology는 변하지 않는다.
6. 한명의 관리자가 있다.
7. 전송비용은 없다.
8. 네트워크는 동일하다.

각각의 오류를 통해 문제들과 잠재적인 해결방법에 대해 말해보자.

## 1. 네트워크는 신뢰할 수 있다.

### 문제

**네트워크를 통한 호출은 실패한다.**

오늘날 대다수의 시스템들은 다른 시스템들을 호출한다. 3rd 파티 시스템(결제 게이트웨이, 회계 시스템, CRMs)들과 통합하나? 웹 서비스 콜을 하는가? 호출이 실패하면 무슨일이 발생하는가? 만약 데이터를 쿼리한다면, 간단한 재시도만 하면 된다. 그러나 만약 너가 명령어를 전송한다면 무슨일이 발생하는가? 간단한 예제를 살펴보자.

```java
var creditCardProcessor = new CreditCardPaymentService();
creditCardProcessor.Charge(chargeRequest);
```

우리가 HTTP 시간 초과 예외를 받는다면 어떤 일이 발생하는가? 만약 서버가 요청을 수행하지 못한다면, 우리는 다시 시도할 것이다. 그러나 요청을 처리 했다면, 우리는 고객들에게 2번 책임을 묻지 않는다는 것을 확실히 할 필요가 있다. 너는 서버를 idempotent(몇번을 수행해도 값이 변하지 않게) 하게 함으로써 이렇게 할 수 있다. 이것은 만약 너가 같은 책임 요청에 대해 10번 호출한다면, 고객은 오직 한번만 책임을 물게 될 것이다. 만약 너가 적절히 이러한 에러들을 처리하지 않는다면, 너의 시스템 비결정적인 것이다. 이러한 경우들을 처리하는 것은 정말 빨리 복잡해 질 수 있다.

### 해법

만약 네트워크를 통한 호출이 실패한다면, 우리는 무얼 할 수 있을까? 우리는 자동적으로 재시도하도록 할 수 있을 것이다. 큐잉 시스템은 이러한 상황에 매우 좋다. 큐잉 시스템은 보통 store and forward 라고 불리는 패턴을 사용한다. 수신자에게 메세지를 전달하기 전에, 로컬에 메시지를 저장한다. 만약, 수신자가 오프라인이라면, 큐잉 시스템은 메세지 전송을 재시도 한다. [MSMQ](http://www.simpleorientedarchitecture.com/msmq-basics/) 가 이러한 큐잉 시스템의 예제이다.

그러나 이러한 변경은 너의 시스템의 설계에 큰 영향을 끼칠 것이다. 너가 request/response 모델에서 fire and forget으로 변경하는 것이다. 너는 응답을 더 이상 기다리지 않기 때문에, 너의 시스템을 통해 사용자의 이동경로들을 변경해야 한다. 너는 단지 각각의 웹서비스 호출을 큐 전송으로 변경할 수 없다.

### 결론

너는 아마 요새 네트워크들은 신뢰할 수 있다고 말할지도 모른다. 그리고 그것들은 그렇다. 그러나 일은 일어난다. 하드웨어와 소프트웨어는 전원 공급, 라우터, 업데이트 실패, 약한 무선 신호, 네트워크 혼잡, 설치류, 상어 등에 고장 날 수 있다. 그래, 상어 : [Google is reinforcing undersea data cables with Kevlar after a series of shark bites](https://www.theguardian.com/technology/2014/aug/14/google-undersea-fibre-optic-cables-shark-attacks).

그리고 거기에도 사람들의 측면도 있다. 사람들은 DDOS 공격을 시작하거나 물리적인 장비들을 파괴할 수 있다.

이게 너가 현재 기술 스택을 버리고 메시징 시스템을 사용해야 한다는 것을 의미할까? 아니다! 너는 너가 해야하는 투자로 가질 실패의 리스크를 저울질 할 필요가 있다. 너는 인프라와 스프트웨어에 투자 함으로써 실패의 기회를 최소화 할 수 있다. 많은 경우에, 실패는 선택사항이다. 그러나 분산시스템을 설계할때 너는 실패를 고려할 필요가 있다.



## 2. 지연은 없다.

### 문제

**네트워크에 대한 호출은 즉각적인 것이 아니다.**

인터넷을 통한 메모리 호출과 호출 사이에는 7배의 차이가 있다. 너의 어플리케이션은 네트워크의 존재를 알아야만 한다. 이것은 너가 원격 호출로부터 지역 호출을 명확하게 분리해야 하는 것을 의미한다. 예제를 살펴보자

```javascript
var viewModel = new ViewModel();
var documents = new DocumentsCollection();
foreach (var document in documents)
{
  var snapshot = document.GetSnapshot();
  viewModel.Add(snapshot);
}
```

자세히 보지 않으면, 괜찮아 보인다. 그러나, 여기에는 2개의 원격 호출이 있다. 2번째 줄은 문서 요약들의 목록을 가져오기 위해서 한번 호출 한다. 5번째 줄에서 각각의 문서들에 대해 많은 정보를 가져오기 위해 다른 호출을 한다. 이건 고전적인 [Select n+1 problem](https://stackoverflow.com/questions/97197/what-is-n1-select-query-issue) 이다. 네트워크 지연을 고려하려면, 너는 한번 호출할때, 모든 요구되는 데이터를 리턴해야만 한다. 일반적인으로 지역 호출은 미세하게 세분화 될 수 있지만, 원격 호출은 더 크게 세분화 되어야 한다. 이게 분산 객체와 "network transparency"가 죽은 이유이다. 그러나 모두가 분산 객체가 안좋은 생각이라는 것에 동의 함에도 불구하고, 몇몇 사람들은 아직까지 lazy loading 이 항상 좋은 생각이라고 생각한다.

```javascript
var employee = EmployeeRepository.GetBy(someCriteria)
 
var department = employee.Department;
var manager = department.Manager;
 
foreach (var peer in manager.Employees;)
{
    // do something
}
```

너는 네트워크 호출을 하는 더 괜찮은 getter를 생각 할 수 없을 것이다. 그러나, 위의 코드에서 각각의 "." 호출은 데이터베이스의 이동에 방아쇠를 당길 수 있다.

### 해법

**너가 필요로 하는 모든 데이터를 가져와라**

만약 너가 원격 호출을 한다면, **너가 필요로 하는 모든 데이터를 가져오는 것**을 확실히 해라.

네트워크 커뮤니케이션은 수다스러워서는 안된다.

**데이터를 클라이언트들에게 더 가까이 옮겨라**

다른 가능한 해법은 **데이터를 클라이언트들에게 더 가까이 옮기는 것**이다. 만약 너가 클라우드를 사용한다면, 너의 클라이언트의 위치를 고려하여, 가능한 지역을 신중하게 골라라. 캐싱 역시 네트워크 호출의 숫자를 최소화 하는데 도움을 줄 수 있다. 정적 컨텐츠에 대해, CDNs는 다른 좋은 선택이다.

**데이터의 흐름을 뒤집어라**

원격 호출을 없애는 다른 선택은 **데이터의 흐름을 뒤집는 것**이다. 다른 서비스를 쿼링하는 것 대신에, 우리는 Pub/Sub을 사용하고, 데이터를 지역적으로 저장할 수 있다. 이 방식에서, 우리는 우리가 이것을 필요로 할때 데이터를 가질 것이다. 당연히, 약간의 복잡함을 가져오지만, 이것은 툴박스에서 매우 좋은 툴이 될 수 있다.

### 결론

지연은 LANs 에서는 문제가 아닐 수도 있지만, WANs 혹은 인터넷으로 넘어간다면, 지연이 발생하는 것을 알 수 있다. 이것이 메모리 호출로부터 네트워크 호출이 명확하게 분리되어야 하는지 중요한 이유이다. 너는 마이크로서비스 아키텍쳐 패턴을 적용할때 이것을 반드시 마음속에 염두하여야 한다. 너는 그냥 지역 호출을 원격 호출로 변경해서는 안된다. 이것은 너의 시스템을 거대한 진흙 덩어리로 변하게 할 것이다.



## 3. 대역폭 (데이터 전송 능력)은 무한하다.

### 문제

### 해법

### 결론



## 4. 네트워크는 안전하다.

### 문제

### 해법

### 결론



## 5. Topology는 변하지 않는다.

### 문제

### 해법

### 결론



## 6. 한명의 관리자가 있다.

### 문제

### 해법

### 결론



## 7. 전송비용은 없다.

### 문제

### 해법

### 결론



## 8. 네트워크는 동일하다.

### 문제

### 해법

### 결론







