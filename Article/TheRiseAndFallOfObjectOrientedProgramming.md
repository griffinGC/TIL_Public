# 객체지향 프로그래밍의 부상과 몰락

객체지향프로그래밍은 아직 죽지 않았다. 그러나 예전에 비해서 많이 덜 보편화 되어있다.

90년대로 돌아가보면, 나는 객체 지향 프로그래밍 도입에 대한 많은 컴퓨터 과학 강좌들과 교과서들이 있었던 것을 기억한다. 그것은 다음 물결인 "the thing" 이었다. 만약 당신이 그 스타일로 프로그래밍 해보지 않았다면, 당신은 아마 나쁜 프로그래머였거나 최소한 슬프게도 뒤쳐져 있었던 것이다. ([behind the curve]([https://dictionary.cambridge.org/ko/%EC%82%AC%EC%A0%84/%EC%98%81%EC%96%B4/be-behind-the-curve](https://dictionary.cambridge.org/ko/사전/영어/be-behind-the-curve)))

그때로 돌아가자면, 컴퓨터 과학 학생들은 매우 엄격하고 독단적인 방식으로 OOP를 배웠다. 현직자들은 객체와 클래스들의 형태로 그들의 어플리케이션을 구조화 하기 위해 노력했을 뿐 아니라, 객체와 클래스들의 용어의 관점에서 *problem space* 에 대해 생각하도록 되어 있었다. 이 관행을 "객체 지향 분석과 설계" 라고 한다.

그러나, 몇년이 지나면서 사람들은 객체 지향에 대한 엄격한 접근은 많은 문제를 발생시킨다는 것을 깨닫기 시작했다. 이러한 문제들은 코드를 복잡하고, 이해하기 어렵고, 테스트하기 어렵게 만드는 경향이 있었다.

OOP는 다른 것들보다 몇몇 문제 영역에 더 적합하다는 것이 밝혀 졌다. 예를 들어, OOP는 아직까지 윈도우나 버튼들 같은 유저 인터페이스를 만드는 가장 자연스러운 방법이다. 그러나 관계형 데이터 베이스에 객체지향을 적용시키려는 노력은 진행중인 재앙이다.

내가 발견한 몇가지 문제들이 있다



## "Platypus" 효과

> "오리너구리" 효과

현실 세계는 항상 잘 짜여진 속성을 가지고 깔끔한 카테고리로 쪼개지지 않는다. 예를 들면, 당신이 동물의 왕국을 나타내는 클래스 계층을 만든다고 가정하자. 여기에는 냉혈동물이고, 비닐로 둘러싸이고, 알을 낳는 파충류가 있다. 온혈동물이고, 털이있고, 새끼를 기르는 포유류가 있다. 그리고 조류, 양서류, 무척추 동물 등이 있다.

그리고 당신의 카테고리중 어느 곳에도 맞지 않아 보이는 오리너구리가 있다. 당신은 어떻게 하겠습니까? 새로운 카테고리를 만들거나 전체 분류 스키마를 다시 생각해야합니까? 어떤 접근이든 노력과 프로그램 복잡도의 관점에서 큰 비용이 든다.



## 깊은 클래스 계층

내가 구글에서 일할때, 사용자 인터페이스를 만드는 goog.ui 라는 자바 스크립트 라이브러리가 있었던 걸로 기억한다. 이 라이브러리에 UI 컴포넌트들 중 하나에 대한 상속 계층 구조 예제를 살펴보자

```javascript
class ToolbarColorMenuButton
* inherits from ColorMenuButton
  * inherits from MenuButton
    * inherits from Button
      * inherits from Control
        * inherits from Component
          * inherits from EventTarget
            * inherits from Disposable
              * inherits from Object
```

9개의 계층이 있다. 매우 많다.



이러한 높은 레벨의 클래스들 중 많은 것들은 오직 적은 수의 하위 클래스와 관련있는 속성들과 메소드로  "오염" 된다. 예를 들면, "Control" 클래스는 [90](https://google.github.io/closure-library/api/goog.ui.Control.html)개가 넘는 메소드들이 있다. 구체적인 하위 클래스가 무상태일지라도 상태를 설정하는 것에 대한 메소드가 존재한다. 자식을 가지는 컨트롤에 대한 이해가 없을지라도 자식을 추가하고 삭제하는 메소드가 존재한다.

이러한 복잡성의 큰 이유는 이 라이브러리의 저자가 컴포넌트들이 버튼이나 슬라이더 혹은 가지고 있는 색 같은 다양한 측면들을 클래스 계층의 다른 부분들로 넣음으로써 그것들을 조직화 시키려고 노력했다는 것이다. 

그러나 이러한 다른 측면들은 실제로 서로 관련이 없다. 커피컵이 빨간색이라는 것, 세라믹으로 만들어졌다는 것 같은 사실들은 매우 독립적인 속성들이다. 빨간색 커피 컵을 "세라믹으로 만든 물건들" 혹은 "집기구" 같은 카테고리에 넣는 것 보다 "빨간색 물건들의 카테고리"로 넣는 것이 더 알맞은 것은 아니다. 카테고리는 *정신적, 사회적 구성* 이기 때문에 둘 중 선택은 임의의 선택이다.



내가 구글에서 지난 몇년 동안 일하면서, 나는 goog.ui에 대체물로써 의도된 "Quantum Wiz" 라고 불리는 유저 인터페이스 툴킷을 만들었다. (일반적인 구글 스타일에서, 방정식으로 쓰인) 우리가 가진 많은 규칙들 중 하나는 아래와 같은 것이었다.

```sh
composition > inheritance
```

일반적으로 영어에서, 이렇게 말한다.

*"코드 재사용의 수단으로써 상속 보다는 작은 빌딩 블록으로 컴포넌트의 기능을 조립할 수 있는 능력인 composition을 선호해라."*

예를 들면, 버튼이 색깔이 있다고 한다면, 새로운 "Color Button" 이라는 클래스를 만드는 것보다 일반적인 "Button" 객체를 사용하고 "Color"라는 측면을 속성이나 자식 객체로 추가하는 것이다.

이러한 명령의 결과로 새로운 툴킷에 대한 클래스 계층은 상대적으로 얕고, 올바르게 호출한다면 오직 2 혹은 3레벨만을 가졌다. 이것은 더 강력할 뿐만 아니라 이해하고 사용하기 쉬웠다.



## Object들은 실제가 아니다

Buckminster Fuller는 말했다. "존재하는 것들은 없다." 그의 말의 의미는 사물의 구별은 대부분 인간의 편견 이라는 것이다.

예를 들어, 내가 앉아있는 소파는 분자의 힘들에 의해 함께 묶여진 원자들의 집합이다. 그러나 이러한 원자들 역시 방에 있는 다른 물체들인 카페트, 테이블 심지어 방에 있는 공기로부터 힘을 받는다. 그리고 소파 자체는 천, 나무 금속 스프링과 같은 다양한 부분들로 구성된다. 이것들 역시 분자들의 힘에 의해 묶인다. 소파는 하나의 물체(object)인가 여러개 인가? 어쩌면 우주 전체라는 오직 하나의 물체(object)가 있을수도 있다.

인간의 시각과 촉각은 대부분 색상과 촉감 같은 표면속성에 반응하기 때문에, 우리는 표면에 기반하여 세계를 분류하는 경향이 있다. 대신에 우리가 직접적으로 우리를 둘러싸는 객체들 내부에 있는 원자 구성을 느낀다고 상상해보라. 우리는 아마 집에 있는 배관과 배선을 나타내는 "구리" 물체(object), 방의 기체를 나타내는 "질소", "물", "나무" 등을 볼 수 있을 것이다.

Fuller의 요점은 우리의 세계를 구별되는 "물체들"로 "변환"하는 능력은 자의적이며, 물리적 현실보다는 인간의 심리를 반영하는 능력이라는 것이다.

객체 지향 상속은 물체들을 클래스로 조직화 시키는 것에 대한 것이기 때문에, 실제 세계를 잘 모델링할 수 없다. 모델이 잘하는 것은 인간이 실세계에 대해 생각하는 방식이다.



## 메소드도 실제가 아니다

약 20년전에 소프트웨어 밴더의 기술 담당자가 우리회사의 엔지니어들에게 OOP에 대해 설명하던 때의 에피소드가 기억난다. 그는 객체지향이 실세계를 모델링하는 방법이라고 주장하려고 했고, 그가 제시한 예시는 커피컵 같은 것이었다. 그는 컵은 "drink()" 라는 메소드를 가질 수 있다고 말했다.

내가 그것에 아주 강한 리액션을 했던 것으로 기억한다. 나는 그가 말하는 것이 완전 말도 안된다고 생각했다. 물리적 객체는 그것이 만들어진 구체적인 목적보다 많은 다른 사용처를 가진다. 나는 커피컵을 종이를 누르는데 쓰거나 문을 고정하는데 쓸 수 있다. 이것이 커피컵이 "holdDownPapers()" 혹은 "keepDoorOpen()" 메소드를 가지는 것을 뜻하는가? 나는 커피컵을 무기, 장난감, 예술 작품으로 사용할 수 있다. 심지어 컵을 산산조각 내거나, 가루로 갈거나, 창의적인 방식으로 남은 부분을 사용할 수 있다.



## 내부 vs 외부 로직

엄격한 OOP 스타일의 원칙중 하나는 밖으로 부터 객체의 내부 상태를 변경할 수 없어야 한다는 것이다. 객체의 상태를 변경하는 어떤 비지니스나 어플리케이션 로직은 객체 그 자체에서 메소드로써 구현 되어야 한다. 예를 들면, 만약 너가 텍스트 필드의 모든 텍스트를 지우고 싶다면, 아래와 같은 간단한 방법을 써서는 안된다.

```java
textField.value = ""; // Set to empty string
```

위의 것은 규칙을 위반한 것이다. 대신 아래와 같이 작성해야 한다.

```java
textField.clear(); // Clear the content of the field
```

간단한 연산에서는 괜찮다. 그러나 특히 연산들이 객체들 사이에서 복잡한 관계를 처리할때는, 자제력을 잃어버리기 쉽다.

가끔 알고리즘이 객체의 밖에 있을때가 더 괜찮을 때가 있다. 이건 진짜 강조해야할 문제다. 이 문제들에서, 당신은 *명사* 혹은 *동사* 에 대해 더 신경 쓰는가?

여기 구체적인 예시가 있다. 최근에 나는 컴파일러 작업을 시작했다. 과거에 컴파일러들을 작성했을때, 내부 데이터의 설계에 매우 엄격한 OOP 접근 방식을 사용했다. 거기에는 추상 문법 트리, 표현식 그래프, 타입 등을 나타내는 다양한 클래스 계층이 있다.

일반적으로 컴파일러는 각각 패스의 결과물이 다음 패스의 입력으로 들어가는 "passes" 혹은 일련의 단계들을 통해 이러한 데이터 구조를 처리한다.

과거에 나는 권장하는 OOP 스타일에 따라 운영되는 개별적인 객체들의 각각의 패스에 로직을 넣는 경향이 있었다. 이것은 내가 패스들을 추가할 수록 더 복잡한 객체들이 나오는 불행한 결과를 가졌다.

설상가상으로 이러한 객체들에 대해 단위 테스트를 작성하는 것은 어려워졌다. 이러한 복잡한 객체들은 그것들을 만들기 전에 많은 기반시설들을 필요로 한다. 그리고 이것은 객체를 테스트하기 위해서, 내가 모든 전제조건을 만족하기위해 많은 발판들을 만들어야 한다는 것을 의미한다.

결과적으로, 테스트들은 작업의 많은 부분을 낭비했기 때문에 내 테스트 커버리지는 안좋은 경향이 있었다.

최근에 나는 다른 접근 방식을 취했다. 최근에 만든 나의 컴파일러에서, 이러한 모든 내부 구조들은 데이터를 가지고 있는 것 말고는 아무것도 하지 않는 "dumb" 이다. 객체들을 조작하고 변경하는 모든 것들은 객체의 밖에 있다.

이건 코드를 체계화 하는데 매우 큰 이점이 있다. 각각의 알고리즘은 소스파일에 퍼져 있기 보다는 한 장소에 집중 되어 있다. 내가 주어진 컴파일러 패스를 테스트하고 싶을때, 나는 손쉽게 예시 객체들을 만들 수 있고 패스로 넘겨 줄 수 있다. 결과적으로 나의 테스트는 작성하기 쉬워진다. 이건 내가 많은 테스트를 작성할 수 있고, 내가 이전에 했던 것보다 더 많은 테스트 커버리지를 가질 수 있다는 것을 의미한다.



## 관계형 데이터베이스

앞서 객체지향에서 관계형 데이터베이스를 다루는 문제에 대해 언급했다. ORM은 한 전문가에 의해 [The Vietnam of Computer Science](http://blogs.tedneward.com/post/the-vietnam-of-computer-science/) 으로 불렸다.

내 일반적인 견해로는 큰 데이터를 다룰때, 당신의 레코드들을 "객체" 로써 생각해서는 안된다. 관계형 데이터베이스는 매우 강력하지만, 그들이 제공하는 힘은 매우 "object-like(객체 같은 것)" 가 아니다. 나는 데이터의 관계형 스트림에 대해 나누고, 변경하고, 수학 연산자를 사용하여 데이터를 합치는 *fluid(유동체)* 같은 것으로 생각하는 경향이 있다.



## 함수형 프로그래밍

지난 수십년 동안, 함수형 프로그래밍 (FP)에 대한 관심이 증가되어왔다. OOP 처럼, 함수형 프로그래밍도 단지 한 가지 어떤 것이라기 보다는 양식적 원칙들의 집합이다. 그러나 이것의 요지는 OOP는 객체들의 *interacting(상호작용)* 과 *communicating(의사소통)* 에 초점을 맞춘 반면에, FP에서 강조하는 것은 그것들을 변환하는 것이다. "transforming" 함으로써 내가 말하고자 하는 것은 당신이 객체를 가지고, 그것을 함수로 보내고 결과물이 입력값의 변환을 나타내는 완전히 새로운 객체가 되는 것을 의미한다. 원래 객체는 유지되거나 버려지지만 어찌되었든 변경되거나 수정되지 않는다.

나는 어디서는 FP를 쓰고, 어디서는 OOP를 쓰는 "hybrid" 방식을 선호한다. FP가 매우 빛을 발하는 경우도 있지만, OOP가 탁월한 선택인 경우도 있다.

나는 많은 FP열성자들이 모든 객체들이 불변하고, 수정이 아닌 변형만 되는 "pure" 함수형 언어의 열렬히 옹호한다는 것을 안다. 그러나 pure한 방식이 상대적으로 직접적인 프로그래밍 연습을 하고 *퍼즐*로 바꾸는 경향이 있다는 것을 발견했다. 그 방법은 뇌 티저를 즐기는 사람들에게는 재미있고 어필이 되는 영리하고 명확한 것이지만, 다른 사람들에게는 전혀 이해할 수 없는 것이다.

결과적으로 나는 FP를 사용하는 경향이 있다. 내가 생각할때 이해할 수 있다고 생각하는 곳에서, 내 코드를 읽는 일반적인 프로그래머가 이해할 수 있다고 생각하는 방식에서 사용한다. 



객체 지향 프로그래밍은 예전 같지 않다. 여전히 좋은 도구이고, 배울 가치가 있다. 그러나 이것의 받침대는 떨어져 나갔고, 25년전에나 봤을법한 종교적 열정으로 이것을 옹호하는 사람은 본적이 없을 것이다.

### 함께 보면 좋을 것들

[Engineering-insights](https://medium.com/machine-words/engineering-insights-15ed954bbcf7)

[Talin’s Index of Essays](https://medium.com/@dreamertalin/talins-index-of-essays-8dd168df0f62)

