# 객체지향 프로그래밍의 부상과 몰락

객체지향프로그래밍은 아직 죽지 않았다. 그러나 예전에 비해서 많이 덜 보편화 되어있다.

90년대로 돌아가보자면 나는 객체 지향 프로그래밍 도입에 대한 많은 컴퓨터 과학 강좌들과 교과서들이 있었던 것을 기억한다. 그것은 다음 물결인 "the thing" 이었다. 만약 당신이 그 스타일로 프로그래밍 해보지 않았다면, 당신은 아마 나쁜 프로그래머였거나 최소한 슬프게도 뒤쳐져 있었던 것이다. ([behind the curve]([https://dictionary.cambridge.org/ko/%EC%82%AC%EC%A0%84/%EC%98%81%EC%96%B4/be-behind-the-curve](https://dictionary.cambridge.org/ko/사전/영어/be-behind-the-curve)))

그때로 돌아가서, 컴퓨터 과학 학생들은 매우 엄격하고 독단적인 방식으로 OOP를 배웠다. 현역들은 객체와 클래스들의 형태로 그들의 어플리케이션을 구조화 하기 위해 노력했을 뿐 아니라, 객체와 클래스들의 용어의 관점에서 *problem space* 에 대해 생각해야했다. 이 연습은 "객체 지향 분석과 설계" 로 알려져 있다.

그러나, 몇년이 지나면서 사람들은 객체 지향에 대한 엄격한 접근은 많은 문제를 발생시킨다는 것을 깨닫기 시작했다. 이러한 문제들은 코드를 복잡하고, 이해하기 어렵고, 테스트하기 어렵게 만드는 경향이 있었다.

OOP는 다른 것들보다 몇몇 문제 영역에 더 적합하다는 것이 밝혀 졌다. 예를 들어, OOP는 아직까지 윈도우나 버튼들 같은 유저 인터페이스를 만드는 가장 자연스러운 방법이다. 그러나 관계형 데이터 베이스에 객체지향을 적용시키려는 노력은 진행중인 재앙이다.

내가 발견한 몇가지 문제들이 있다



## "Platypus" 효과

> "오리너구리" 효과

현실 세계는 항상 잘 짜여진 속성을 가지고 깔끔한 카테고리로 쪼개지지 않는다. 예를 들면, 당신이 동물의 왕국을 나타내는 클래스 계층을 만든다고 가정하자. 여기에는 냉혈동물, 비닐로 둘러싸이고, 알을 낳는 파충류가 있다. 다른데는 온혈, 털이있고, 새끼를 기르는 포유류가 있다. 그리고 조류, 양서류, 무척추 동물 등이 있다.

그리고 당신의 카테고리중 어느 곳에도 맞지 않아 보이는 오리너구리가 있다. 당신은 어떻게 하겠습니까? 새로운 카테고리를 만들거나 전체 분류 스키마를 다시 생각해야합니까? 어떤 접근이든 노력과 프로그램 복잡도의 관점에서 큰 비용이 든다.



## 깊은 클래스 계층

내가 구글에서 일할때, 사용자 인터페이스를 만드는 goog.ui 라는 자바 스크립트 라이브러리가 있었던 걸로 기억한다. 이 라이브러리에 UI 컴포넌트들 중 하나에 대해 상속 계층 예제를 살펴보자

```javascript
class ToolbarColorMenuButton
* inherits from ColorMenuButton
  * inherits from MenuButton
    * inherits from Button
      * inherits from Control
        * inherits from Component
          * inherits from EventTarget
            * inherits from Disposable
              * inherits from Object
```

9개의 계층이 있다. 매우 많다.

더 나빠진다.

이러한 높은 레벨의 클래스들 중 많은 것들은 오직 적은 수의 하위 클래스와 관련있는 속성들과 메소드로  "오염" 된다. 예를 들면, "Control" 클래스는 [90](https://google.github.io/closure-library/api/goog.ui.Control.html)개가 넘는 메소드들이 있다. 구체적인 하위 클래스가 무상태일지라도 상태를 설정하는 것에 대한 메소드가 존재한다. 자식을 가지는 컨트롤에 대한 이해가 없을지라도 자식을 추가하고 삭제하는 메소드가 존재한다.

이러한 복잡성의 가장 큰 이유는 이 라이브러리의 저자가 컴포넌트들의 다른 측면(컴포넌트가 버튼이든 슬라이더든 간에 혹은 어떤 색을 가지고 있던 간에 같이)을 클래스 계층의 다른 부분들로 넣음으로써 그것들을 조직화 시키려고 노력했다는 것이다. 

그러나 이러한 다른 측면들은 실제로 각자 서로 관련이 없다. 커피컵이 빨간색이라는 것, 세라믹으로 만들어졌다는 것 과 같은 사실은 매우 독립적인 속성들이다. 빨간색 커피 컵을 "세라믹으로 만든 물건들" 혹은 "집기구" 같은 카테고리에 넣는 것 보다 "빨간색 물건들의 카테고리"로 넣는 것이 더 알맞은 것은 아니다. 카테고리는 *정신적, 사회적 구성* 이기 때문에 둘 중 선택은 임의의 선택이다.



내가 구글에서 지난 몇년 동안 일하면서, 나는 goog.ui에 대체물로써 의도된 "Quantum Wiz" 라고 불리는 유저 인터페이스 툴킷을 만들었다. (일반적인 구글 스타일에서, 방정식으로 쓰인) 우리가 가진 많은 규칙들 중 하나는 아래와 같은 것이었다.

```sh
composition > inheritance
```

일반적으로 영어에서, 이렇게 말한다.

"코드 재사용의 수단으로써 상속 보다는 composition을 선호해라. 즉, 작은 빌딩 블록에서 컴포넌트의 기능을 조립할 수 있는 능력"

예를 들면, 버튼이 색깔이 있다고한다면, 새로운 "Color Button" 이라는 클래스를 만드는 것보다 일반적인 "Button" 객체를 사용하고 "Color"라는 측면을 속성이나 자식 객체로 추가하는 것이다.

이러한 명령의 결과로 새로운 툴킷에 대한 클래스 계층은 상대적으로 얕고, 올바르게 호출한다면 오직 2 혹은 3레벨만을 가졌다. 이것은 더 강력할 뿐만 아니라 이해하고 사용하기 쉬웠다.



## 물체(Object)들은 실제가 아니다

Buckminster Fuller는 말했다. "존재하는 것들은 없다." 그의 말의 의미는 사물의 구별은 대부분 인간의 편견 이라는 것이다.

예를 들어, 내가 앉아있는 소파는 분자의 힘들에 의해 함께 묶여진 원자들의 집합이다. 그러나 이러한 원자들 역시 방에서 다른 물체들 -- 카페트, 테이블 심지어 방에 있는 공기로부터 힘을 받는다. 그리고 소파 자체는 천, 나무 금속 스프링과 같은 다양한 부분들로 구성된다. 이것들 역시 분자들의 힘에 의해 묶인다. 소파는 하나의 물체(object)인가 여러개 인가? 아쩌면 우주 전체 라는 오직 하나의 물체(object)가 있을수도 있다.

인간의 시각과 촉각은 대부분 색상과 촉감 같은 표면속성에 반응하기 때문에, 우리는 표면에 기반하여 세계를 분류하는 경향이 있다. 대신에 우리가 직접적으로 우리를 둘러싸는 객체들 내부에 있는 원자 구성을 느낀다고 상상해보라. 우리는 아마 집에 있는 배관과 배선을 나타내는 "구리" 물체(object), 방의 기체를 나타내는 "질소", "물", "나무" 등을 볼 수 있을 것이다.

Fuller의 요점은 우리의 세계를 구별되는 "물체들"로 "변환"하는 능력은 자의적이며, 물리적 현실보다는 인간의 심리를 반영하는 능력이라는 것이다.

객체 지향 상속은 물체들을 클래스로 조직화 시키는 것에 대한 것이기 때문에, 실제 세계를 잘 모델링할 수 없다. 모델을 잘 만드는 것은 실세계에 대해 인간이 생각하는 방식이다.