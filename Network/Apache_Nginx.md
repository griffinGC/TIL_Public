# Apache Nginx

> Apache와 Nginx에 관한 글

## Nginx

### 더 적은 자원으로 더 빠르게

- **트래픽이 많은 웹사이트**의 확장성을 위해 설계한 **비동기 이벤트 기반** 구조의 웹서버 소프트웨어
  - 높은 성능의 로드 밸런서
- 가벼움과 높은 성능을 목적으로 설계됨
- 장점
  - 다수의 연결을 효과적으로 처리 가능
  - 대부분의 코어 모듈이 Apache보다 적은 리소스로 **더 빠르게 동작 가능**
  - 더 작은 쓰레드로 클라이언트의 요청들을 처리 가능
  - 서버의 자원 활용도면에서 Nginx가 더 뛰어남
- Node.js와 Nginx를 함께 써서, Nginx를 프록시 서버로 앞단에 두면 버퍼 오버플로우 취약점에 의한 공격을 방지 가능
  - 즉, 익명의 사용자가 직접적인 웹서버로의 접근을 막을 수 있음
  - 버퍼 오버플로우
    - 메모리 공간을 초과하는 경우 오버플로우가 되고, 이때 사용되지 않아야 할 영역에 데이터가 덮어씌워져서 주소, 값을 바꾸는 공격
- **HTTP 프록시와 웹서버 기능**
- **메일 프록시 기능**
- **리버스 프록시 서버 기능**
  - 클라이언트의 요청을 수행 가능한 Server로 전달하고 서버의 응답을 클라이언트에게 리턴
- **로드밸런싱 기능**
  - Nginx가 요청을 받아 was에 중계해주는 역할 수행
  - 들어오는 클라이언트의 요청을 서버들의 그룹으로 분배하고 각각의 경우에 선택된 서버로부터 적절한 클라이언트로 응답을 리턴

### Event-driven

- 여러개의 커넥션을 모두 Event Handler를 통해 **비동기 방식**으로 처리해 **먼저 처리되는 것부터 로직이 진행**되게끔 만듬
  - Node.js 역시 이벤트 기반
  - 현재의 일이 끝나는 것을 기다리지 않고 바로 다음 일 수행
  - Concurrency 하게 업무 처리 가능
  - 프로세스와 스레드 생성 비용 없음 => 적은 자원 사용

- 구조
  - 하나의 Master Process와 다수의 Worker Process
  - Master Process
    - 설정 파일을 읽고 유효성 검사
    - Worker Process 관리
  - Worker Process
    - Worker Process의 개수는 설정 파일에서 정의 됨
    - 정의된 프로세스 개수와 사용 가능한 CPU 코어 숫자에 맞게 자동으로 조정 됨



## Apache

### 전통의 강자

- 스레드 / 프로세스 기반 구조
- **요청 하나당 스레드 하나 사용**
  - 하나의 스레드는 하나의 클라이언트
    - 접속이 많아지면 효율성 떨어짐
- 사용자가 많으면 많은 스레드 생성
  - **메모리 및 cpu 낭비 심함**
- MPM 방식으로 처리
  - Multi Processing Module

- **서버의 프로세스가 블로킹 되면 요청 처리 못해서 처리 끝날때까지 기다림**
  - Keep Alive 사용하면 해결가능 하지만, 이로인해 대량 접속시 효율 떨어짐
- **php모듈등 직접 적재 가능**
- **nginx보다 모듈이 다양함**

### Prefork MPM

- **하나의 자식 프로세스가 하나의 스레드**를 갖는 구조, 자식 프로세스는 최대 1024개 까지 가능
- 스레드간 메모리 공유 안함 
  - 독립적 => 메모리 많이 필요
- 실행중인 프로세스를 복제하여 실행 
  - 메모리 영역까지 복제
- 응답 프로세스를 미리 띄어놓고 플라이언트 요청시 자식 프로세스가 반응하게 되는 방식
- 쉬운 디버깅 가능
- Single CPU 또는 Dual CPU에서 성능 좋음

### Worker MPM

- **Prefork보다 메모리 사용량 적음**
  - 통신량이 많거나 동시 접속자가 많은 사이트에 적합
- **프로세스당 여러 스레드 가능**
  - 최대 64개의 스레드 처리 가능
  - 각 스레드는 한번에 한 연결 담당
- 스레드 간에 메모리 공유
- Multi CPU 에서 성능 좋음



## Forward Proxy vs Reverse Proxy

> Proxy라는 용어는 다른 것을 대신해주는 것을 뜻함
>
> **캐싱 기능 존재**

![proxies](https://i.stack.imgur.com/0qpxZ.png)



### Forward Proxy

- 내부망에서 인터넷으로 나갈때 사용
  - 클라이언트가 인터넷으로 연결하려고 할때 Forward Proxy를 통해 나감
  - **클라이언트를 대신하여 동작**
  - 서버에게 클라이언트가 누군지 감추는 역할 수행

- 클라이언트가 웹 사이트 접속하는 것을 막음
- 본 서버의 결과를 프록시 서버를 통해서 클라이언트에게 전달
- **캐싱** 기능이 있음
  - 자주 사용하는 컨텐츠에 월등한 성능 향상을 가져 올 수 있음



### Reverse Proxy

- **웹 서버에서 동작**
  - 클라이언트가 웹서버로 직접 접근 못하도록 만듬
- 모든 트래픽이 중간에 있는 프록시 서버를 강제로 거치게 됨
- **서비스의 메인 서버를 노출 시키고 싶지 않을 경우**
- 중간에 거치는 프록시 서버만이 클라이언트에게 노출 됨
- **로드밸런싱**

### Proxy 장점

- **보안**

  - IP를 숨길 수 있음

- 성능

  - **캐싱** 기능

  - 트래픽 분산

    



## Load balancing vs Reverse Proxy

- 로드밸런싱이랑 리버스 프록시랑 유사하지만 완전히 같은건 아님

### 로드밸런싱

- 여러 서버가 필요한 경우 사용
- 여러 서버를 사용할 경우 각 서버의 용량을 최대한 활용하고 모든 서버의 과부하 방지 가능
- 클라이언트가 보는 오류 응답 수를 줄여서 사용자의 경험 향상 가능
- 여러 서버 중에 한 서버가 중단되면 그것을 감지하고 다른 서버로 요청을 전환하여 수행
- 세션 지속성 가짐
  - 즉, 클라이언트의 모든 요청을 동일한 서버로 보냄

### 리버스 프록시

- 로드 밸랜서의 경우 여러 서버가 있는 경우 의미 있지만, 서버가 **하나**만 있어도 리버스 프록시를 배포하는게 좋음
- **보안 향상**
- **확장성과 유연성 향상**
- **캐싱**
  - 클라이언트에 응답 반환하기 전에 리버스 프록시는 해당 서버의 사본을 리버스 프록시 서버의 로컬에 저장
  - 클라리언트가 동일한 요청을 하면 저장되어있던것 리턴
- **SSL 종료**
  - 클라이언트와 서버 사이의 트래픽을 암호화 함으로써 공용 네트워크 통과시 보호
    - 단, 해독이나 암호화에 시간이 좀 걸릴 수 있음
  - 그래서 들어오는 요청에 대한 해독과 서버의 응답 암호화를 리버스 프록시 서버에서 수행
  - 이로 인해, 백엔드 서버는 자신의 기능에만 집중 가능



## 출처

> https://taetaetae.github.io/2018/06/27/apache-vs-nginx/

> https://m.blog.naver.com/jhc9639/220967352282

> https://opentutorials.org/module/384/3462

> https://www.nginx.com/resources/glossary/reverse-proxy-vs-load-balancer/#:~:text=A%20reverse%20proxy%20accepts%20a,server%20to%20the%20appropriate%20client.

> https://www.lesstif.com/system-admin/forward-proxy-reverse-proxy-21430345.html

> https://forteleaf.tistory.com/entry/Reverse-Proxy-%EC%99%80-Load-Balencer

> https://velog.io/@wijihoon123/Nginx%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80

> https://icarus8050.tistory.com/57

> https://cntechsystems.tistory.com/24

