# HTTP HTTPS

> http://www.ktword.co.kr/abbr_view.php?nav=2&m_temp1=648&id=1283
>
> https://www.joinc.co.kr/w/Site/Network_Programing/AdvancedComm/HTTP
>
> https://developer.mozilla.org/ko/docs/Web/HTTP/Overview

## HTTP

> https://shlee0882.tistory.com/110

- 웹상에서 웹 서버 및 웹브라우저 상호 간의 데이터 전송을 위한 응용계층(L7) 프로토콜
- 요청 및 응답의 구조
  - 동작 형태가 **클라이언트 / 서버** 모델로 동작
  - 클라이언트의 **URI**를 이용해서 서버에 접속하고, 데이터 요청
- 메세지 교환 형태의 프로토콜
  - 클라이언트와 서버간에 **HTTP 메세지**를 주고 받으며 통신
  - HTTP의 응답 빛 요청 메시지 구성
  - HTTP메세지 내 헤더 항목들
- 트랜잭션 중심의 **비연결성**프로토콜
  - Connectionless
    - 연결 유지 안함
  - Stateless
    - 이전의 상태 유지 안함
  - 장점
    - **접속 유지는 최소한으로 하기 때문에 불특정 다수를 대상으로하는 서비스에 적함**
  - 단점
    - **클라이언트의 이전 상태를 알 수 없음**
      - 로그인을 해도 로그 정보 유지 불가
      - 쿠키를 이용하여 해결
- 전송 프로토콜 - **TCP**
- 전송 포트 - **80**
- keep alive
  - 클라이언트측에 연결을 유지하라는 신호를 보내기 위해서 사용됨

### URI

- 자원의 **위치**를 알려주는 프로토콜
  - http://www.example.com/index.jsp
    - index.jsp 같은 것

### Method

- GET
- POST
- PUT
- DELETE
- HEAD
- OPTIONS
- TRACE

### 데이터 포맷

> HTTP/2에서는 메시지가 프레임속으로 캡슐화 되어서 인간이 읽을 수 없음

#### 요청

- 시작줄, **헤더(Header)**와 **바디(Body)**로 구성됨
  - 시작줄
    - 요청 방식(메서드), URI, HTTP버전으로 구성됨
    - `GET www.naver.com HTTP/1.1`
  - 헤더
    - 요청에 대한 정보를 담고 있음
    - referer
      - 클라이언트가 넘어온 이전 페이지
      - 이를 이용하면 블로그의 방문자 유입경로 같은 정보를 얻을 수 있음
    - connection
      - 연결 정보를 알 수 있음
      - keep-alive 같은것
  - 바디
    - 요청을 보낼때 함께 보낼 데이터

#### 응답

- 시작줄, 헤더, 바디로 구성됨
  - 시작줄
    - **HTTP버전, 상태코드, 상태메시지**로 구성
  - 헤더
    - 응답에 대한 정보
  - 바디
    - 응답에 대한 메시지 (보통 HTML)

### 응답코드

- `1XX`
  - 조건부 응답

- `2XX`
  - 서버가 요청을 성공적으로 처리했을 경우

- `3XX`
  - 리다이렉션 (redirection)
  - 요청완료를 위해 다른 페이지로 보내야 하는 경우

- `4XX`
  - 클라이언트 요청에 오류가 있을 경우

- `5XX`
  - 서버 오류

### Keep Alive

- HTTP 1.1부터 지원
- 기존의 HTTP에서는 웹페이지 하나를 표시하기 위해 수십번의 연결을 맺고 끊는 과정이 필요함 이러한 점을 극복
  - 처음 연결되면 HTML을 받고 **바로 접속을 끊는것이 아닌, 모두 받고 연결을 끊음**
- Keep Alive 동작시 수행순서
  1. 웹서버 연결
  2. HTML 다운
  3. 이미지, css, js 다운
  4. 모든 문서 다운 되면 연결 종료
- http 요청 헤더에 keep-alive 방식을 지원하도록 명시
  - `Connection:keep-alive`





## HTTPS

> https://jeong-pro.tistory.com/89
>
> https://wayhome25.github.io/cs/2018/03/11/ssl-https/
>
> https://opentutorials.org/course/228/4894

- HTTP 보안 버전
  
  - 기본포트는 443
  - **[공개키 암호화 방식](./공개키암호화.md)** 사용
  
- 도청, 통신 상대방 위장, 임의 내용 변경 등 방지

  - **SSL 인증서**를 이용하여 암호화 시킴

- SSL/TLS 등 다른 프로토콜들을 조합시켜 **통신 내용을 암호화** 시킴
  - 안전하긴 하지만 사용자와 서버 간의 트래픽을 암호화하지는 않음
  - SSL은 표현 계층의 프로토콜

- 브라우저나 앱과 인터넷 웹서버 와의 HTTP에 대해서 암호화 해줌

  - 하지만, HTTP에 비해 느림

- 통신을 하며 암호화(SSL) 키를 서로 안전하게 주고 받고, 키 값이 노출되지 않도록 안전하게 해주는 것이 https 서버 인증서

- SSL 레이어 위에 HTTP를 통과 시키는 방식

  1. 평문의 HTTP문서는 SSL레이어를 통과하며 암호화 됨
2. 도착한 목적지에서 SSL 레이어를 통과하며 복호화 되서 웹브라우저에 전달

  - HTTPS는 SSL프로토콜 위에서 돌아가는 **프로토콜**

### SSL 디지털 인증서

- 클라이언트와 서버간의 통신을 제 3자가 보증해주는 전자화된 문서
- 클라이언트가 서버에 접속한 직후에 서버는 클라이언트에게 이 인증서 전달 (밑에서 다시 설명)
- 장점
  - 통신내용이 공격자에게 노출되는 것을 막을 수 있음
  - 클라이언트가 접속하려는 서버가 신뢰 할 수 있는 서버인지 판단 가능
  - 통신 내역의 악의적인 변경 방지 가능

### SSL 통신과정

- SSL 핸드쉐이크
  - 암호화된 HTTP 메시지 교환전에 서버와 클라이언트 간에 수행
  - 목적
    - 프로토콜 버전번호 교환
    - 양쪽이 알고있는 premaster secret 키 생성 및 교환
    - 양쪽의 신원 인증
    - 채널을 암호화 하기 위한 임시 세션 키 생성

### HTTPS 통신흐름

- HTTPS사이트들의 공개키는 저장소인 CA(Certificate Authority)에 저장되어 있음
  - CA는 민간 기업이나 아무나 운영할 수 없고 신뢰성이 검증된 기업만 운영 가능

1. 서버회사 A는 HTTPS 적용을 위해 공개키와 개인키를 생성

2. CA회사를 선택하여 그 회사에 공개키를 관리해달라고 계약

3. CA회사들은 그 회사만의 공개키와 개인키가 있음

   - CA회사는 CA기업의 이름과 A서버의 공개키, 공개키의 암호화 방법등의 정보를 담은 **인증서를 만들고**, 해당 인증서를 **CA기업의 개인키로 암호화** 해서 A서버에게 제공

     CA회사 -> A회사 (인증서 생성하고, CA기업의 개인키로 암호화 해서 A서버에게 제공)

4. A 회사는 암호화된 인증서를 가지게 됨

   - A회사는 A회사의 **공개키로 암호화된 HTTPS 요청이 아닌 요청이 오면** 이 암호화된 인증서를 클라이언트에게 줌

     A사 -> 클라이언트 (암호화된 인증서)

5. 클라이언트 입장에서, A사로 파일을 요청할경우 HTTPS요청이 아니므로 **CA기업이 A회사의 정보를 CA기업의 개인키로 암호화한 인증서를 클라이언트가 받게 됨**

   A사 -> 클라이언트(CA회사의 개인키로 암호화된 인증서 == A사에게 받은 인증서)

6. **CA회사의 공개키는 브라우저가 이미 알고 있음**

7. 브라우저가 CA기업 리스트를 탐색하며 인증서에 적혀있는 CA회사 이름이 같으면 해당 CA회사의 공개키를 알고있는 브라우저는 해독 가능

   - 브라우저는 해독해서 A서버의 공개키 얻음
   - **즉, A사로부터 받은 CA회사의 개인키로 암호화된 인증서를 브라우저가 해독(인증)해서 A서버의 공개키를 얻음**

8. 클라이언트가 A회사와 통신할때는 **얻은 A회사의 공개키로 암호화 해서 요청 보냄**

즉, A사가 CA회사와 계약 맺음 

-> CA회사는 자기 회사의 개인키로 암호화해서 인증서를 A사에게 제공 

-> 클라이언트가 A사에게 데이터 요청하면 A사가 CA회사로 부터 받은 인증서를 클라이언트에게 제공 

-> 클라이언트의 브라우저는 그 받은 인증서를 해독해서 A서버의 공개키를 얻음 

-> A사에 요청 보낼때 얻은 공개키로 암호화해서 요청보냄