# HTTP HTTPS

> http://www.ktword.co.kr/abbr_view.php?nav=2&m_temp1=648&id=1283
>
> https://www.joinc.co.kr/w/Site/Network_Programing/AdvancedComm/HTTP
>
> https://developer.mozilla.org/ko/docs/Web/HTTP/Overview

## HTTP

> https://shlee0882.tistory.com/110

- 웹상에서 웹 서버 및 웹브라우저 상호 간의 데이터 전송을 위한 응용계층(L7) 프로토콜
- 요청 및 응답의 구조
  - 동작 형태가 **클라이언트 / 서버** 모델로 동작
  - 클라이언트의 **URI**를 이용해서 서버에 접속하고, 데이터 요청
- 메세지 교환 형태의 프로토콜
  - 클라이언트와 서버간에 **HTTP 메세지**를 주고 받으며 통신
  - HTTP의 응답 빛 요청 메시지 구성
  - HTTP메세지 내 헤더 항목들
- 트랜잭션 중심의 **비연결성**프로토콜
  - Connectionless
    - 연결 유지 안함
  - Stateless
    - 이전의 상태 유지 안함
  - 장점
    - **접속 유지는 최소한으로 하기 때문에 불특정 다수를 대상으로하는 서비스에 적함**
  - 단점
    - **클라이언트의 이전 상태를 알 수 없음**
      - 로그인을 해도 로그 정보 유지 불가
      - 쿠키를 이용하여 해결
- 전송 프로토콜 - **TCP**
- 전송 포트 - **80**
- keep alive
  - 클라이언트측에 연결을 유지하라는 신호를 보내기 위해서 사용됨

### URI

- 자원의 **위치**를 알려주는 프로토콜
  - http://www.example.com/index.jsp
    - index.jsp 같은 것

### Method

- GET
- POST
- PUT
- DELETE
- HEAD
- OPTIONS
- TRACE

### 데이터 포맷

> HTTP/2에서는 메시지가 프레임속으로 캡슐화 되어서 인간이 읽을 수 없음

#### 요청

- 시작줄, **헤더(Header)**와 **바디(Body)**로 구성됨
  - 시작줄 (맨 첫째줄)
    - 요청 방식(메서드), URI, HTTP버전으로 구성됨
    - `GET www.naver.com HTTP/1.1`
  - 헤더 (두번째줄 부터)
    - 요청에 대한 정보를 담고 있음
    - referer
      - 클라이언트가 넘어온 이전 페이지
      - 이를 이용하면 블로그의 방문자 유입경로 같은 정보를 얻을 수 있음
    - connection
      - 연결 정보를 알 수 있음
        - HTTP 1.1은 영구 연결을 지원하지 않으므로, 응답이 완료되면 닫히도록 하는 close 연결 옵션 포함해야 함
        - `Connection : close`
      - keep-alive 같은것
  - 빈줄
    - 요청에 대한 모든 메타정보 전송 의미
  - 바디
    - 요청을 보낼때 함께 보낼 데이터
      - POST, PUT일 경우에만 존재

#### 응답

- 시작줄, 헤더, 바디로 구성됨
  - 시작줄
    
    - **HTTP버전, 상태코드, 상태메시지**로 구성
    
      `HTTP/1.1 200 OK`
  - 헤더
    
    - 응답에 대한 정보
  - 빈줄
  
  - 바디
    
    - 응답에 대한 메시지 (보통 HTML)

### 응답코드

- `1XX`
  - 조건부 응답

- `2XX`
  - 서버가 요청을 성공적으로 처리했을 경우

- `3XX`
  - 리다이렉션 (redirection)
  - 요청완료를 위해 다른 페이지로 보내야 하는 경우

- `4XX`
  - 클라이언트 요청에 오류가 있을 경우

- `5XX`
  - 서버 오류

### Keep Alive

- HTTP 1.1부터 지원
- 기존의 HTTP에서는 웹페이지 하나를 표시하기 위해 수십번의 연결을 맺고 끊는 과정이 필요함 이러한 점을 극복
  - 처음 연결되면 HTML을 받고 **바로 접속을 끊는것이 아닌, 모두 받고 연결을 끊음**
- Keep Alive 동작시 수행순서
  1. 웹서버 연결
  2. HTML 다운
  3. 이미지, css, js 다운
  4. 모든 문서 다운 되면 연결 종료
- http 요청 헤더에 keep-alive 방식을 지원하도록 명시
  - `Connection:keep-alive`





## HTTPS

> https://jeong-pro.tistory.com/89
>
> https://wayhome25.github.io/cs/2018/03/11/ssl-https/
>
> https://opentutorials.org/course/228/4894

- HTTP 보안 버전
  
  - 기본포트는 443
  - **[공개키 암호화 방식](./공개키암호화.md)** 사용
  
- 도청, 통신 상대방 위장, 임의 내용 변경 등 방지

  - **SSL 인증서**를 이용하여 암호화 시킴

- SSL/TLS 등 다른 프로토콜들을 조합시켜 **통신 내용을 암호화** 시킴
  - 안전하긴 하지만 사용자와 서버 간의 트래픽을 암호화하지는 않음
  - SSL은 표현 계층의 프로토콜

- 브라우저나 앱과 인터넷 웹서버 와의 HTTP에 대해서 암호화 해줌

  - 하지만, HTTP에 비해 느림

- 통신을 하며 암호화(SSL) 키를 서로 안전하게 주고 받고, 키 값이 노출되지 않도록 안전하게 해주는 것이 https 서버 인증서

- SSL 레이어 위에 HTTP를 통과 시키는 방식

  1. 평문의 HTTP문서는 SSL레이어를 통과하며 암호화 됨
2. 도착한 목적지에서 SSL 레이어를 통과하며 복호화 되서 웹브라우저에 전달

  - HTTPS는 SSL프로토콜 위에서 돌아가는 **프로토콜**

### SSL 디지털 인증서

- 클라이언트와 서버간의 통신을 제 3자가 보증해주는 전자화된 문서
- **클라이언트가 서버에 접속한 직후에 서버는 클라이언트에게 이 인증서 전달** (밑에서 다시 설명)
  - 즉, SSL 통신에 사용할 공개키를 클라이언트에게 제공
- 장점
  - 통신내용이 공격자에게 노출되는 것을 막을 수 있음
  - 클라이언트가 접속하려는 서버가 신뢰 할 수 있는 서버인지 판단 가능
  - 통신 내역의 악의적인 변경 방지 가능
- 기능
  - **클라이언트가 접속한 서버가 신뢰할 수 있는 서버임을 보장**
  - **SSL 통신에 사용할 공개키를 클라이언트에게 제공**



### SSL 인증서 내용

- **서비스의 정보**
  - 인증서를 발급한 CA
  - 서비스의 도메인
  - 등등
- **서버 측 공개키**
  - 공개키의 내용
  - 공개키의 암호화 방법

### SSL 인증서가 서비스를 보증하는 방법

- 웹브라우저가 서버에 접속할때 서버는 제일 먼저 인증서를 제공
- 브라우저가 자기가 가지고 있는 CA의 리스트에 있는지 없는지를 확인해서 있을 경우, 인증기관의 공개키를 브라우저는 가지고 있다는 것이기 때문에, 공개키를 이용해서 인증서를 복호화 함



### 인증서 생성 과정 및 전송

- HTTPS사이트들의 공개키는 저장소인 CA(Certificate Authority)에 저장되어 있음
  - CA는 민간 기업이나 아무나 운영할 수 없고 신뢰성이 검증된 기업만 운영 가능

1. 서버회사 A는 HTTPS 적용을 위해 **공개키**와 **개인키**를 생성

2. CA회사를 선택하여 그 회사에 **자신 회사(A사)의 공개키**를 관리해달라고 계약

3. CA회사들은 그 회사만의 공개키와 개인키가 있음

   - CA회사는 CA기업의 이름과 A서버의 공개키, 공개키의 암호화 방법등의 정보를 담은 **인증서(SSL인증서)를 만들고**, 해당 인증서를 **CA기업의 개인키로 암호화** 해서 A서버에게 제공

     **CA회사 -> A회사 (SSL인증서)**

4. A 회사는 암호화된 인증서**(SSL인증서)**를 가지게 됨

   - A회사는 A회사의 **공개키로 암호화된 HTTPS 요청이 아닌 요청이 오면 HandShake 이후** 이 암호화된 인증서를 클라이언트에게 줌

     A사 -> 클라이언트 (암호화된 인증서 == SSL 인증서)

5. 클라이언트 입장에서, A사로 파일을 요청할경우 HTTPS요청이 아니므로 **CA기업이 A회사의 정보를 CA기업의 개인키로 암호화한 SSL인증서를 클라이언트가 받게 됨**

   A사 -> 클라이언트(CA회사의 개인키로 암호화된 인증서 == A사에게 받은 인증서)

6. **CA회사의 공개키는 브라우저가 이미 알고 있음**

7. 브라우저가 CA기업 리스트를 탐색하며 인증서에 적혀있는 CA회사 이름이 같으면 해당 **CA회사의 공개키를 알고있는 브라우저는 해독 가능**

   - 브라우저는 해독해서 A서버의 공개키 얻음
   - **즉, A사로부터 받은 CA회사의 개인키로 암호화된 SSL인증서를 브라우저가 해독(인증)해서 A서버의 공개키를 얻음**

8. 클라이언트가 A회사와 통신할때는 **얻은 A회사의 공개키로 암호화 해서 요청 보냄**

즉, A사가 CA회사와 계약 맺음 

-> CA회사는 자기 회사의 개인키로 암호화해서 인증서를 A사에게 제공 

-> 클라이언트가 A사에게 데이터 요청하면 A사가 CA회사로 부터 받은 인증서를 클라이언트에게 제공 

-> 클라이언트의 브라우저는 그 받은 인증서를 해독해서 A서버의 공개키를 얻음 

-> A사에 요청 보낼때 얻은 공개키로 암호화해서 요청보냄



### SSL 동작 방식

- **SSL은 암호화된 데이터를 전송하기 위해서 공개키와 대칭키를 혼합해서 사용**

  - 공개키만 사용하면 **컴퓨팅 파워를 많이 사용하기 때문에 혼합해서 사용**

- 실제 데이터

  - 대칭키 방식으로 암호화

- 대칭키 공유시 사용하는 기법

  - 공개키 방식 사용

- Handshake -> Session -> Session Terminate

- **Handshake**

  - 암호화된 HTTP 메시지 교환전에 서버와 클라이언트 간에 수행
  - 목적
    - 프로토콜 버전번호 교환
    - 양쪽의 신원 인증
    - 채널을 암호화 하기 위한 임시 세션 키 생성
    - 인증서를 서버가 클라이언트에게 전송
    - 클라이언트는 인증서안에 담겨있는 공개키를 이용해서 랜덤으로 생성한 값을 공개키로 암호화해서 서버로 전송
      - 서버는 전송된 랜덤값을 복호화 해서 서버와 클라이언트가 서로가 통신할때 사용할 똑같은 session key를 갖게 되는것

  1. 클라이언트가 서버에 접속
     - Client Hello
     - **클라이언트가 생성한 랜덤데이터를 전송**
     - 클라이언트가 지원하는 암호화 방식들을 서버에 전송
       - 자신이 처리할 수 있는 기법
     - 세션 아이디
  2. 서버는 응답
     - Server Hello
     - **서버 측에서 생성한 랜덤데이터 전송**
     - 서버가 선택한 클라이언트의 암호화 방식
       - 자신도 처리 할 수 있으면서 가장 안전한 암호화 기법 알려줌
     - **인증서 (SSL 인증서)**
  3. 클라이언트가 인증서가 브라우저에 내장되어있는 CA리스트에 의해서 발급되었는지 확인
     - 있다면, 공개키로 인증서 복호화 시도
       - **복호화 된다면, 인증서가 인증기관에 의해서 발급된 것이라는 것을 알 수 있음**
       - **인증기관에 의해서 보증된것이라는 것을 확신 가능**
     - 인증서 안에는 서버가 생성한 공개키가 인증서 안에 있음
       - 인증서 안에 있는 **서버 측 공개키를 클라이언트가 획득하게 됨**
     - 이전에 클라이언트와 서버가 주고 받은 **랜덤키**를 이용해서 **pre master secret** 생성
       - 실제로 데이터를 전송하는 session 단계에서 실제 데이터를 안전한 방식으로 주고 받을때 사용하는 **대칭키**에 랜덤데이터 사용
       - 대칭키를 서버로 보낼때 누가 탈취하는 것을 방지하기 위해 사용하는 것이 인증서 안에 들어있던 **공개키**
         - 클라이언트가 만든 **pre master secret를 인증서 안에 있던 서버의 공개키를 이용하여 암호화**
       - 암호화 한 pre master secret 값을 클라이언트는 서버에게 전송
         - 전송한 내용이 유출되더라도 pre master secret 값을 암호화한 개인키는 서버만이 가지고 있기 때문에 서버만이 해독 가능
  4. 서버는 클라이언트가 보낸 pre master secret 값을 자신의 개인키를 이용하여 복호화 함
     - 서버와 클라이언트가 모두 pre master secret 값을 가지게 됨
     - 그리고 둘다 일련의 과정을 거쳐 pre master secret 값 -> master secret 값으로 바꿈
     - master secret을 이용해서 session key 생성
     - session key는 실제로 데이터를 주고 받을때 대칭키 방식을 이용해서 암호화할때 사용하는 키
  5. 클라이언트와 서버는 핸드쉐이크 종료 후 다음단계로 진행

- Session

  - 실제로 데이터를 주고 받는 단계
  - 실제 데이터를 주고 받기 전에 session key로 암호화 해서 전송
    - 암호화 할때 방식은 대칭키 방식
    - 받은 것은 session key로 복호화 하고, 보낼때는 다시 session key 로 암호화 해서 전송

- Session Terminate

  - 서로가 통신이 끝났음을 서로에게 알려주고 통신에서 사용한 세션키를 폐지
  - 세션키가 유출되더라도, 세션의 수립과 종료가 아주 짧은 시간에 일어나기 때문에 이미 세션은 종료가 되어있는 상태

