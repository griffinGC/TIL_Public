# Spring 기본 정리



## 1. Spring 특징

- 크기와 부하가 경량
  - 특정한 인터페이스를 구현하거나 상속 받을 필요 없어서 가벼움
  - POJO(Plain Old Java Object) 방식의 프레임워크
- 제어역행(IoC : Inversion of Control) 기술 통해 애플리케이션의 느슨한 결합 
  - 제어권이 사용자가 아니라 프레임 워크에 있어서 필요에 따라 스프링에서 사용자의 코드 호출
- 관점지향(AOP : Aspect Oriented Programming) 프로그래밍을 위한 풍부한 지원
  - 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당 기능을 분리하여 관리 할 수 있음
- 객체의 생명 주기와 설정을 포함하고 관리함
  - 일종의 컨테이너
  - 자바 객체를 직접 관리
- 간단한 컴포넌트로 복잡한 구성 및 설정 가능
- 의존성 주입(DI : Dependency Injection) 지원
  - 계층이나 서비스들간에 의존성이 존재할 경우 프레임워크가 서로 연결 시켜줌

- 영속성과 관련된 다양한 서비스 지원
  - `iBatis` ,`Hibernate` 등 이미 완성도 높은 데이터베이스 처리 라이브러리와 연결 할 수 있는 인터페이스 제공
- 확장성이 높음
  - 수많은 라이브러리가 이미 스프링에서 지원 중이고, 사용되는 라이브러리를 별도로 분리하기에 용이

- 대한민국 전자정부 표준 프레임워크의 기반 기술



## 2. 주요 구성요소

 ### 스프링 핵심 개념

- DI
- IoC
- AOP & AOP Proxy
- AOP in Spring



### 주요 구성 요소

- IoC / DI
- AOP
- PSA



### DI (Dependency Injection, 의존성 주입)

- 스마트폰에 배터리를 넣는 것을 의존성 주입과 비유적으로 비슷하다고 생각 할 수 있음

- 종류

  - Setter Injection

    ```java
    // Setter Injection
    B b = new B();
    A a = new A();
    a.set(b);
    ```

    

  - Construction Injection

	  ```java
    // Construction Injection
    B b = new B();
    A a = new A(b);
    ```

- Spring에서 DI
  - 명세서(**XML**)에 따라서 자동적으로 부품을 활용하여 제품 조립하는 형태
  - 일체형과는 반대로 제품을 생성
  - 작은 부품부터 큰 부품순으로 이동하면 조립 
  - IoC (Inversion of Control)
    - 기본적인 완제품 순서와 다르게 작은부품에서 큰 부품 순으로 역순으로 만들기 때문

- DI 구현

  - 객체의 생성과 도킹에 대한 내용은 소스코드상이 아닌 별도의 `.xml`  파일에 존재함

    ```xml
    <bean id=“record” class=“di.SprRecord”></bean> // 빈 객체 생성
    <bean id=“view” class=“di.SprRecordView”> // 빈 객체 생성
      <property name=“record” ref=“record”></property> // setRecord() 호출 
    </bean>
    ```

  - XML 활용하는 경우 VIEW에 대한 객체만을 요청했을 뿐, 실제 내부사항은 Java에 보이지 않음

  - 새로운 클래스의 bean 객체 만들어 XML에 주입 시켜줘도, 기존 소스 변경 없이 새로운 형태의 객체 적용 가능

    

### IoC 컨테이너 (스프링 컨테이너)

- 외부에서 제어 함
- 용어
  - 빈 (Bean) 
    - 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트
  - 빈 팩토리 (Bean Factory)
    - 오브젝트의 생성과 관계 설정 제어를 담당하는 IoC 오브젝트
  - 애플리케이션 컨텍스트 : IoC 컨테이너 (스프링 컨테이너)
    - DI를 위한 빈 팩토리에 애플리케이션 개발을 하는데 필요한 여러가지 컨테이너 기능을 추가한 것
  - 설정정보 / 설정 메타정보
    - 구성정보 or 형상정보 (XML)
  - 스프링 컨테이너(IoC 컨테이너)
    - IoC 방식으로 빈을 관리한다는 의미에서 애플리케이션 컨텍스트나 빈 팩토리를 의미
    - ApplicationContext 인터페이스를 구현한 클래스의 오브젝트
  - EJB (엔터프라이즈 자바빈)
    - 효율적으로 서버 관리를 해주고, 프로그램 관련 문제를 알아서 처리해준다는 개념
    - 연결관계가 복잡하고, 무겁고, 독립적이지 못함
  - DL (Dependency Lookup)
    - JNDI 같은 저장소에 의해 관리되고 있는 bean을 개발자들이 직접 컨테이너에서 제공하는 API를 이용하여 lookup하는것을 뜻함
    - 컨테이너와의 종속성이 생김
    - 오브젝트간에 디커플링을 해주지만 오브젝트 컨테이너 밖에서는 사용 불가
  - DI (Dependency Injection)
    - 각 class 사이의 의존 관계를 빈 설정 정보를 바탕으로 container가 자동적으로 연결해 주는 것을 뜻함.
    - lookup과 관련된 코드들이 오브젝트 내에서 완전히 사라지고 컨테이너에 의존적이지 않은 코드를 작성할 수 있음
- 컨테이너가 IoC 컨테이너로써 동작하려면 `POJO클래스`와 `설정 메타정보`가 필요
- IoC 컨테이너
  - 객체의 명세서를 작성하고, 스프링 라이브러리는 해당 명세대로 생성
  - 생성된 객체들을 보관하는 공간



### AOP (Aspect Oriented Programming)

- 스프링의 3대 기반 기술 중 하나
- 공통 관심사(Cross-Cutting Concern)와 이에 영향 받는 객체간의 결합도를 낮추는 것
- 메인 프로그램의 비지니스 로직으로부터 보조 기능들을 고립시키는 프로그래밍 방식
- 사용 이유
  - 부가적인 업무가 강한 응집력을 가지고 있을 경우, 소스 관리 및 개발 업무 진행이 복잡하고 어려움
  - 서비스 추상화가 어려운 것을 해결하기 위함. (OOP의 보완적 개념)
  - 클래스들이 공통으로 갖는 기능이나 절차 등을 하나의 것으로 묶어 빼내어 별도로 관리하기 위함
  - ex. 로그인, 트랜젝션, 보안, 캐싱 등등
- 장점
  - 곳곳의 흩어져 있는 다양한 관심사항이 하나의 장소로 응집
  - 서비스 모듈이 자신의 핵심 기능에 대한 코드만 포함하고 그 외의 관심 사항은 Aspect로 옮겨지므로 코드가 깔끔해지고, 가독성이 높아짐
- 부가적인 기능만 분리하여 Aspect라는 모듈로 만들어서 설계하고 개발하는 방법
- 핵심 코드는 **Core(Primary) Concern**
- 부가 / 보조 업무 코드는 **Cross-Cutting Concern**
  - Cross-Cutting Concern
    - 다른 관심사에 영향을 미치는 프로그램의 aspect
    - 다른 관심사로부터 깨끗이 분해되지 못하는 경우가 있을 수 있고, 분산되거나 얽히는 일이 일어날 수 있음



### AOP Proxy

- Proxy
  - 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장하여 클라이언트의 요청을 받아주어 처리하는 대리자 역할
- 함수 호출자는 주요 업무가 아닌 보조 업무를 프록시에게 맡기고, 프록시는 내부적으로 이런 보조 업무를 처리
- 주 업무 코드는 보조 업무가 필요한 경우, 해당 Proxy만 추가하면 되고 필요없게 되면 Proxy 제거
- 보조 업무의 탈 부착이 쉬워짐
  - 주 업무 코드는 보조 업무 코드의 변경으로 인해서 발생하는 코드 수정 작업이 필요 없어짐

- 호출 및 처리 순서
  1. Proxy 호출
  2. 보조 업무 처리
  3. Proxy 처리 함수가 실제 구현 함수 호출 및 주 업무 처리
  4. 제어권이 다시 Proxy 함수로 넘어오고 나머지 보조 업무 처리
  5. 처리 작업 완료 후, 호출 함수로 반환
- 프록시 사용 목적
  - 클라이언트가 타깃에 접근하는 방법을 제어
  - 타깃에 부가적인 기능 부여



### Dynamic Proxy (동적 프록시)

- 프록시 단점

  - 매 번 새로운 클래스 정의 필요
  - 타킷의 인터페이스를 구현하고 위임하는 코드 작성의 번거로움
  - 부가기능 코드의 중복 가능성

- 단점을 해결하기 위해 **Dynamic Proxy** 사용

- 런타임시 동적으로 만들어지는 오브젝트

- 리플렉션 기능을 이용해서 프록시 생성 `java.lang.reflect`

- 타깃 인트페이스와 동일한 형태로 생성

- FactoryBean 을 통해서 생성

  - FactoryBean
    - 스프링을 대신해서 오브젝트의 생성 로직을 담당하도록 만들어진 특별한 빈

- 스프링 빈은 기본적으로 `Class name` 과 `Property` 로 정의

- 스프링은 지정된 클래스 이름을 가지고 리플렉션을 이용해 해당 클래스의 오브젝트를 생성

- 단점

  - 부가기능을 구현할 클래스가 부가기능과 관계없는 메서드들도 인터페이스에 선언된 메서드라면 전부 구현해야함
  - 부가기능과 관계된 메소드들에 구현되는 코드 중복

- 단점 해결 방안

  - `Proxy.newProxyInstance()` 를 통한 프록시 생성
  - `Proxy.newProxyInstance()` 를 호출 할때 전달하는 `InvocationHandler` 인터페이스의  단일메소드인 `invoke()` 에 부가 기능을 단 한번만 구현함으로써 해결 가능

  - 다이나믹 프록시 오브젝트는 클래스 파일 자체가 존재하지 않음
  - 빈 오브젝트로 등록 불가
  - FactoryBean 인터페이스 활용



### 패턴

- 개발 디자인 패턴을 뜻함 2가지 존재
  - 데코레이션 패턴
    - 타깃의 코드에 손대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은 채로 새로운 기능을 추가할때 유용한 방법
  - 프록시 패턴
    - 타깃의 기능 자체에는 관여하지 않으면서 접근하는 방법을 제어해주는 프록시를 이용한 방법
  - 패턴의 차이
    - 프록시의 경우 실제 실행될 타깃을 확장하는 것이 아닌, 타깃에 접근하는 방법 자체를 프록시를 통해 가능하게 하는것
    - 데코레이터는 실행 타깃의 확장 의미
- 데코레이터 패턴의 장단점
  - 장점
    - 기존 코드는 수정하지 않고, 확장 및 추가 가능
  - 단점
    - 잡다한 클래스가 많아짐
    - 겹겹이 둘러싼 구조로 구조가 복잡해지면 객체의 정체를 알기 어려움





## 참고자료

> https://ooz.co.kr/170
>
> https://ooz.co.kr/175
>
> https://ooz.co.kr/193?category=818548
